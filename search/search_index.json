{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Cadwyn","text":"<p>Production-ready community-driven modern Stripe-like API versioning in FastAPI</p> <p> </p>"},{"location":"#who-is-this-for","title":"Who is this for?","text":"<p>Cadwyn allows you to maintain the implementation just for your newest API version and get all the older versions generated automatically. You keep API backward compatibility encapsulated in small and independent \"version change\" modules while your business logic stays simple and knows nothing about versioning.</p> <p>This approach may be useful if you want to:</p> <ol> <li>Support many API versions for a long time</li> <li>Have features and bugfixes automatically backported to older API versions</li> </ol> <p>Whether you are a newbie in API versioning, a pro looking for a sophisticated tool, an experimenter looking to build a similar framework, or even someone who just wants to learn about all approaches to API versioning -- Cadwyn has the functionality, theory, and documentation to cover all the mentioned use cases.</p>"},{"location":"#get-started","title":"Get started","text":"<p>It is recommended to read the quickstart tutorial first to get your feet wet with Cadwyn's approach</p>"},{"location":"concepts/","title":"Concepts","text":"<p>This section covers the entirety of features and their rationale in Cadwyn. It can also be used as reference documentation until we have a proper one. First, let's talk about the reasons for using Cadwyn at all.</p> <p>Cadwyn aims to be the most accurate and sophisticated API Versioning model out there. First of all, you maintain zero duplicated code yourself. Usually, in API versioning you would need to duplicate and maintain at least some layer of your application. It could be the database, business logic, schemas, and endpoints. With Cadwyn you avoid duplicating any of that. Internally, it duplicates endpoints and schemas at runtime but none of it becomes your tech debt, none of it becomes your code to support. If you test rigorously, then only some small subset of your tests will need to be duplicated when existing functionality is changed between versions.</p> <p>You define your database, business logic, routes, and schemas only once. Then, whenever you release a new API version, you use Cadwyn's version change DSL to describe how to convert your app to the previous version. So your business logic and database stay intact and always represent the latest version while the version changes make sure that your clients can continue using the previous versions without ever needing to update their code.</p> <p>This allows you to effortlessly maintain hundreds of versions, unlike any other API versioning approach.</p>"},{"location":"concepts/api_version_parameter/","title":"API Version Parameter","text":"<p>Cadwyn adds another routing layer to FastAPI by default: by version parameter. This means that before FastAPI tries to route us to the correct route, Cadwyn will first decide on which version of the route to use based on a version parameter. Feel free to look at the example app with URL path version prefixes and arbitrary strings as versions here.</p>"},{"location":"concepts/api_version_parameter/#api-version-location","title":"API Version location","text":"<p>The version parameter can be passed in two different ways:</p> <ul> <li>As a custom header</li> <li>As a URL path parameter</li> </ul> <p>Cadwyn will use the following defaults:</p> <pre><code>from cadwyn import Cadwyn, Version, VersionBundle\n\napp = Cadwyn(\n    api_version_location=\"custom_header\",\n    api_version_parameter_name=\"X-API-VERSION\",\n    versions=VersionBundle(Version(\"2022-01-02\")),\n)\n</code></pre> <p>but you can change the header name if you want to:</p> <pre><code>from cadwyn import Cadwyn, Version, VersionBundle\n\napp = Cadwyn(\n    api_version_location=\"custom_header\",\n    api_version_parameter_name=\"MY-GREAT-HEADER\",\n    versions=VersionBundle(Version(\"2022-01-02\")),\n)\n</code></pre> <p>or you can use a path parameter:</p> <pre><code>from cadwyn import Cadwyn, Version, VersionBundle\n\napp = Cadwyn(\n    api_version_location=\"path\",\n    api_version_parameter_name=\"api_version\",\n    versions=VersionBundle(Version(\"2022-01-02\")),\n)\n</code></pre>"},{"location":"concepts/api_version_parameter/#api-version-format","title":"API Version format","text":"<p>The version parameter can be formatted in two different ways:</p> <ul> <li>As an ISO date</li> <li>As an arbitrary string</li> </ul> <p>Cadwyn uses the following default:</p> <pre><code>from cadwyn import Cadwyn, Version, VersionBundle\n\napp = Cadwyn(\n    api_version_format=\"date\",\n    versions=VersionBundle(Version(\"2022-01-02\")),\n)\n</code></pre> <p>In the example above only dates will be accepted as valid versions.</p> <p>You can also use an arbitrary string:</p> <pre><code>from cadwyn import Cadwyn, Version, VersionBundle\n\napp = Cadwyn(\n    api_version_format=\"string\",\n    versions=VersionBundle(\n        Version(\"v2\"),\n        Version(\"anything_can_be_a_version\"),\n        Version(\"v1\"),\n    ),\n)\n</code></pre> <p>In the example above any string will be accepted as a valid version. Arbitrary strings can be used, Cadwyn will not sort them. Cadwyn will assume their actual order matches the order of the versions in the <code>VersionBundle</code>.</p>"},{"location":"concepts/api_version_parameter/#api-version-waterfalling","title":"API Version waterfalling","text":"<p>For historical reasons, date-based routing also supports waterfalling the requests to the closest earlier version of the API if the request date parameter doesn't match any of the versions exactly.</p> <p>If the app has two versions: 2022-01-02 and 2022-01-05, and the request date parameter is 2022-01-03, then the request will be routed to the 2022-01-02 version, as it is the closest version, but lower than the request date parameter.</p> <p>An exact match is always preferred to a partial match and a request will never be matched to the higher-versioned route.</p> <p>We implement routing like this because Cadwyn was born in a microservice architecture and it is extremely convenient to have waterfalling there. For example, imagine that you have two Cadwyn services: Payables and Receivables, each defining its own API versions. Payables service might contain 10 versions while Receivables service might contain only 2 versions because it didn't need as many breaking changes. If a client requests a version that does not exist in Receivables, we will just waterfall to some earlier version, making Receivables behavior consistent even if API keeps getting new versions.</p>"},{"location":"concepts/api_version_parameter/#api-version-parameter-title-and-description","title":"API Version Parameter Title and Description","text":"<p>You can pass a title and/or a description to the <code>Cadwyn</code> constructor. It is equivalent to passing <code>title</code> and <code>description</code> to <code>fastapi.Path</code> or <code>fastapi.Header</code> constructors.</p> <pre><code>app = Cadwyn(\n    ...,\n    api_version_title=\"My Great API version parameter\",\n    api_version_description=\"Description of my great API version parameter\",\n)\n</code></pre>"},{"location":"concepts/api_version_parameter/#api-version-context-variables","title":"API Version Context Variables","text":"<p>Cadwyn automatically converts your data to a correct version and has \"version checks\" when dealing with side effects as described in the section above. It can only do so using a special context variable that stores the current API version.</p> <p>You can also pass a different compatible contextvar to your <code>cadwyn.VersionBundle</code> constructor.</p>"},{"location":"concepts/beware_of_data_versioning/","title":"Beware of data versioning","text":"<p>Oftentimes you will want to introduce a breaking change where one of the following is true:</p> <ul> <li>Old data cannot be automatically converted to the structure of the new response</li> <li>New response cannot be automatically migrated to an older response</li> <li>Old request cannot be automatically converted to the HEAD request</li> </ul> <p>This means that you are not versioning your API, you are versioning your data. This cannot be solved by an API versioning framework. It also makes it incredibly hard to version as you now cannot guarantee compatibility between versions. Avoid this at all costs -- all your API versions must be compatible between each other. Data versioning is not a result of a complicated use case, it is a result of errors when divising a new version. I am yet to meet a single case where data versioning is the right way to solve an API versioning problem.</p>"},{"location":"concepts/changelogs/","title":"Changelogs","text":"<p>Cadwyn can automatically generate API changelogs for your versions. By default they are available through the unversioned endpoint <code>GET /changelog</code>. You can also get it from <code>Cadwyn.generate_changelog</code> method.</p>"},{"location":"concepts/changelogs/#hiding-version-changes-and-instructions","title":"Hiding version changes and instructions","text":"<p>Sometimes you might want to do private internal version changes or instructions within the version changes that should not be visible to the public. You can do this by using the <code>cadwyn.hidden</code> function. For example:</p> <pre><code>from cadwyn import hidden, VersionChange, endpoint\n\n\nclass VersionChangeWithOneHiddenInstruction(VersionChange):\n    description = \"...\"\n    instructions_to_migrate_to_previous_version = (\n        hidden(endpoint(\"/users/{user_id}\", [\"GET\"]).had(path=\"/users/{uid}\")),\n    )\n\n\n@hidden\nclass CompletelyHiddenVersionChange(VersionChange):\n    description = \"...\"\n    instructions_to_migrate_to_previous_version = (\n        schema(User).field(\"address\").existed_as(type=str),\n    )\n</code></pre>"},{"location":"concepts/changelogs/#customizing-changelog-endpoint","title":"Customizing changelog endpoint","text":"<p>The changelog endpoint name can be customized by specifying a new name via the <code>changelog_url</code> argument to the <code>Cadwyn()</code> constructor. Accessing this url via the <code>GET</code> request will return the changelog for all versions based on the content of your <code>VersionBundle</code>.</p> <p>If you want to hide the changelog endpoint, pass <code>include_changelog_url_in_schema=False</code> to <code>Cadwyn()</code>.</p> <p>If you want to delete the changelog endpoint, pass <code>changelog_url=None</code> to <code>Cadwyn()</code>.</p>"},{"location":"concepts/changelogs/#changelog-structure-and-entry-types","title":"Changelog structure and entry types","text":"<p>Please, visit the swagger page for your app and check the structure and values of enums in the <code>/changelog</code> endpoint.</p>"},{"location":"concepts/cli/","title":"CLI","text":"<p>Cadwyn has an optional CLI that can be installed with <code>pip install 'cadwyn[standard]'</code>. You can run <code>cadwyn --version</code> to check the current version of Cadwyn.</p> <p>Its main purpose is rendering generated schemas.</p> <p>You can also check Cadwyn's version using the CLI:</p> <pre><code>cadwyn --version\n</code></pre>"},{"location":"concepts/endpoint_migrations/","title":"Endpoint migrations","text":"<p>Note that the <code>endpoint(...)</code> constructor contains a second argument that describes the methods of the endpoints you would like to edit. If you have two routes for a single endpoint and you put both of their methods into the instruction -- as expected, both of them will be changed.</p>"},{"location":"concepts/endpoint_migrations/#defining-endpoints-that-didnt-exist-for-new-versions","title":"Defining endpoints that didn't exist for new versions","text":"<p>If you had an endpoint in an old version but want to delete it in a new version, you must still define it as usual with all your other endpoints but mark it as deleted.</p> <pre><code>@router.only_exists_in_older_versions\n@router.get(\"/users/{user_id}\")\nasync def my_old_endpoint():\n    ...\n</code></pre> <p>and then define it as existing in one of the older versions:</p> <pre><code>from cadwyn import VersionChange, endpoint\n\n\nclass MyChange(VersionChange):\n    description = \"...\"\n    instructions_to_migrate_to_previous_version = (\n        endpoint(\"/users/{user_id}\", [\"GET\"]).existed,\n    )\n</code></pre>"},{"location":"concepts/endpoint_migrations/#defining-endpoints-that-didnt-exist-in-old-versions","title":"Defining endpoints that didn't exist in old versions","text":"<p>If you have an endpoint in your new version that must not exist in older versions for some reason, you define it as usual and then mark it as \"non-existing\" in old versions. Note that this is not the recommended approach when adding new endpoints.</p> <pre><code>from cadwyn import VersionChange, endpoint\n\n\nclass MyChange(VersionChange):\n    description = \"...\"\n    instructions_to_migrate_to_previous_version = (\n        endpoint(\"/companies/{company_id}\", [\"GET\"]).didnt_exist,\n    )\n</code></pre>"},{"location":"concepts/endpoint_migrations/#changing-endpoint-attributes","title":"Changing endpoint attributes","text":"<p>If you want to change any attribute of your endpoint in a new version, you can return the attribute's value in all older versions like this:</p> <pre><code>from cadwyn import VersionChange, endpoint\n\n\nclass MyChange(VersionChange):\n    description = \"...\"\n    instructions_to_migrate_to_previous_version = (\n        endpoint(\"/users/{user_id}\", [\"GET\"]).had(\n            description=\"My old description\"\n        ),\n    )\n</code></pre> <p>However, you only need to have a migration if it is a breaking change for your users.</p>"},{"location":"concepts/endpoint_migrations/#dependency-alteration-warning","title":"Dependency alteration warning","text":"<p>Note that changing endpoint <code>dependencies</code> is only going to affect the initial validation. So Cadwyn will take your altered dependencies and run them on each request to the endpoint but ultimately your endpoint code is always going to use the HEAD version of your dependencies. So be careful.</p> <p>Also note that if some of your dependencies were added at app/router level, they are going to be overwritten by this instruction. Most of the time it is rather safe, however, as all the necessary dependencies will still run on HEAD version.</p>"},{"location":"concepts/endpoint_migrations/#dealing-with-endpoint-duplicates","title":"Dealing with endpoint duplicates","text":"<p>Sometimes, when you're doing some advanced changes in between versions, you need to rewrite your endpoint function entirely. So essentially you'd have the following structure:</p> <pre><code>from fastapi.params import Param\nfrom fastapi.headers import Header\nfrom typing import Annotated\nfrom cadwyn import VersionedAPIRouter\n\nrouter = VersionedAPIRouter()\n\n\n@router.only_exists_in_older_versions\n@router.get(\"/users\")\ndef get_users_by_name_before_we_started_using_params(\n    user_name: Annotated[str, Header()]\n):\n    \"\"\"Do some logic with user_name\"\"\"\n\n\n@router.get(\"/users\")\ndef get_users_by_name(user_name: Annotated[str, Param()]):\n    \"\"\"Do some logic with user_name\"\"\"\n</code></pre> <p>As you see, these two functions have the same parameters and path decorators. And when you have many versions, you can have even more functions like these two. So how do we ask cadwyn to restore only one of them and delete the other one?</p> <pre><code>from cadwyn import VersionChange, endpoint\n\n\nclass UseParamsInsteadOfHeadersForUserNameFiltering(VersionChange):\n    description = (\n        \"Use params instead of headers for user name filtering in GET /users \"\n        \"because using headers is a bad API practice in such scenarios.\"\n    )\n    instructions_to_migrate_to_previous_version = (\n        # We need to specify the name, otherwise, we will encounter an exception due to\n        # having two identical endpoints with the same parameters and path decorators\n        endpoint(\n            \"/users\",\n            [\"GET\"],\n            func_name=\"get_users_by_name_before_we_started_using_params\",\n        ).existed,\n        # We also need to specify the name here because, following the instruction above,\n        # we now have two existing endpoints\n        endpoint(\"/users\", [\"GET\"], func_name=\"get_users_by_name\").didnt_exist,\n    )\n</code></pre> <p>So by using a more concrete <code>func_name</code>, we are able to distinguish between different functions that affect the same routes.</p>"},{"location":"concepts/enum_migrations/","title":"Enum migrations","text":"<p>All of the following instructions affect only OpenAPI schemas and their initial validation. All of your incoming requests will still be converted into your HEAD schemas.</p>"},{"location":"concepts/enum_migrations/#adding-enum-members","title":"Adding enum members","text":"<p>Note that adding enum members can be a breaking change unlike adding optional fields to a schema. For example, if I return a list of entities, each of which has some type, and I add a new type, then my client's code is likely to break.</p> <p>So I suggest adding enum members in new versions as well.</p> <pre><code>from cadwyn import VersionChange, enum\nfrom enum import auto\n\n\nclass MyChange(VersionChange):\n    description = \"...\"\n    instructions_to_migrate_to_previous_version = (\n        enum(my_enum).had(foo=\"baz\", bar=auto()),\n    )\n</code></pre>"},{"location":"concepts/enum_migrations/#removing-enum-members","title":"Removing enum members","text":"<pre><code>from cadwyn import VersionChange, enum\n\n\nclass MyChange(VersionChange):\n    description = \"...\"\n    instructions_to_migrate_to_previous_version = (\n        enum(my_enum).didnt_have(\"foo\", \"bar\"),\n    )\n</code></pre>"},{"location":"concepts/main_app/","title":"Main App","text":"<p>Cadwyn's standard usage involves a single customized FastAPI app: <code>cadwyn.Cadwyn</code>. It accepts all the same arguments as <code>FastAPI</code> does and two more keyword-only arguments:</p> <ul> <li>Required <code>versions: VersionBundle</code> describes all versions within your application</li> <li>Optional <code>api_version_parameter_name: str = \"x_api_version\"</code> is the parameter that Cadwyn will use for routing to different API versions of your app</li> </ul> <p>After you have defined the main app, you can add versioned API routers to it using <code>Cadwyn.generate_and_include_versioned_routers(*routers)</code></p> <pre><code>from cadwyn import VersionedAPIRouter, Cadwyn\nfrom versions import my_version_bundle\n\n\nrouter = VersionedAPIRouter(prefix=\"/users\")\n\n\n@router.get(\"/users/\", tags=[\"users\"])\nasync def read_users():\n    return [{\"username\": \"Rick\"}, {\"username\": \"Morty\"}]\n\n\n@router.get(\"/users/{username}\", tags=[\"users\"])\nasync def read_user(username: str):\n    return {\"username\": username}\n\n\napp = Cadwyn(versions=my_version_bundle)\napp.generate_and_include_versioned_routers(router)\n</code></pre> <p>That's it! <code>generate_and_include_versioned_routers</code> will generate all versions of your routers based on the <code>versions</code> argument.</p>"},{"location":"concepts/main_app/#routing","title":"Routing","text":"<p>Cadwyn is built on header-based routing. First, we route requests to the appropriate API version based on the version header (<code>x-api-version</code> by default). Then we route by the appropriate url path and method. Currently, Cadwyn only works with ISO date-based versions (such as <code>2022-11-16</code>). If the user sends a date that does not have an exact match, Cadwyn picks up the closest lower applicable version. For example, <code>2022-11-16</code> in request can be matched by <code>2022-11-15</code> and <code>2000-01-01</code> but cannot be matched by <code>2022-11-17</code>.</p> <p>However, header-based routing is the default way to use Cadwyn. If you want to use any other form of routing, you can use Cadwyn directly through <code>cadwyn.generate_versioned_routers</code> or subclass <code>cadwyn.Cadwyn</code> to use a different router and middleware. Just remember to update the <code>VersionBundle.api_version_var</code> variable each time you route some request to a version. This variable allows Cadwyn to do side effects and data migrations.</p>"},{"location":"concepts/main_app/#versionedapirouter","title":"VersionedAPIRouter","text":"<p>Cadwyn has its own API Router class: <code>cadwyn.VersionedAPIRouter</code>. You are free to use a regular <code>fastapi.APIRouter</code> but <code>cadwyn.VersionedAPIRouter</code> has a special decorator <code>only_exists_in_older_versions(route)</code> which allows you to define routes that have been previously deleted. First you define the route and than add this decorator to it.</p>"},{"location":"concepts/methodology/","title":"Methodology","text":"<p>Cadwyn implements a methodology that is based on the following set of principles:</p> <ul> <li>Each version consists of \"version changes\" or \"compatibility gates\" which describe independent, atomic differences from the previous version</li> <li>We make a new version if and only if we have breaking changes</li> <li>Versions must have little to no effect on the business logic</li> <li>Versions must always be compatible in terms of data</li> <li>Creating new versions is avoided at all costs</li> <li>Any backward-compatible features must be backported to all compatible versions</li> </ul> <p>These rules give us an ability to have a large number of self-documenting versions while encapsulating their complexity in small version change classes, providing a consistent and stable experience to our users.</p> <p>So if we see that we need to make a breaking change, our general approach is to:</p> <ol> <li>Make the breaking change in your schemas, routes, or business logic</li> <li>Write a version change class (and sometimes a little extra) that describes the difference between the new version and the old version</li> </ol>"},{"location":"concepts/schema_generation/","title":"Schema generation","text":"<p>Cadwyn automatically generates versioned schemas and everything related to them from HEAD version at runtime -- no actual code is being generated. These versioned schemas will be automatically used in requests and responses for versioned API routes.</p>"},{"location":"concepts/schema_generation/#rendering-schemas","title":"Rendering schemas","text":"<p>When you have many versions and schemas, it is quite challenging to know what validators, fields, and other attributes are defined on each schema in any specific version. To address this issue, there is a way to render the generated pydantic models and enums as code using the command-line interface.</p> <p>NOTICE that <code>cadwyn render</code> does not guarantee rendering correct schemas. It is going to be a close enough approximation for manual validation. However, it is not yet ready to be used for production code generation. For example, it doesn't handle schema renamings in class <code>__bases__</code> yet.</p>"},{"location":"concepts/schema_generation/#rendering-a-module","title":"Rendering a module","text":"<p>Here's a way to render the entire module with the schemas:</p> <pre><code>cadwyn render module data.schemas --app=main:app --version=2024-05-26\n</code></pre> <p>This command will print to stdout what the schemas would look like in version 2024-05-26 if they were written by hand instead of generated at runtime by Cadwyn. This command takes the schemas from <code>data/schemas.py</code> module and knows what the schemas would look like based on the version changes from <code>Cadwyn</code> app instance named <code>app</code> and located in <code>main.py</code>.</p>"},{"location":"concepts/schema_generation/#rendering-a-single-model","title":"Rendering a single model","text":"<p>Here's a way to render a single pydantic model or enum with the schemas:</p> <pre><code>cadwyn render model data.schemas:UserCreateRequest --app=main:app --version=2024-05-26\n</code></pre> <p>This command will print to stdout what the <code>UserCreateRequest</code> schema would look like in version 2024-05-26 if it was written by hand instead of generated at runtime by Cadwyn. This command takes the <code>UserCreateRequest</code> schema from <code>data/schemas.py</code> module and knows what the schema would look like based on the version changes from <code>Cadwyn</code> app instance named <code>app</code> and located in <code>main.py</code>.</p>"},{"location":"concepts/schema_generation/#generating-schemas-without-fastapi","title":"Generating schemas without FastAPI","text":"<p>Cadwyn is capable of generating versioned schemas from its version changes even without FastAPI:</p> <pre><code>import cadwyn\nfrom cadwyn.schema_generation import generate_versioned_models\nfrom my_versions import version_bundle, MyVersionedSchema\n\nschema_generators = generate_versioned_models(version_bundle)\nMyVersionedSchemaFrom2025 = schema_generators[\"2025-11-16\"][MyVersionedSchema]\n</code></pre>"},{"location":"concepts/schema_migrations/","title":"Schema migrations","text":"<p>All of the following instructions affect only OpenAPI schemas and their initial validation. All of your incoming requests will still be converted into your HEAD schemas.</p> <p>Please note that you only need to have a migration if it is a breaking change for your users. The scenarios below only describe \"what you can do\" but not \"what you should do\". For the \"should\" part, please refer to the how-to docs.</p>"},{"location":"concepts/schema_migrations/#add-a-field-to-the-older-version","title":"Add a field to the older version","text":"<pre><code>from cadwyn import VersionChange, schema\nfrom pydantic import Field\n\n\nclass MyChange(VersionChange):\n    description = \"...\"\n    instructions_to_migrate_to_previous_version = (\n        schema(MySchema)\n        .field(\"foo\")\n        .existed_as(type=list[str], info=Field(description=\"Foo\")),\n    )\n</code></pre>"},{"location":"concepts/schema_migrations/#remove-a-field-from-the-older-version","title":"Remove a field from the older version","text":"<pre><code>from cadwyn import VersionChange, schema\n\n\nclass MyChange(VersionChange):\n    description = \"...\"\n    instructions_to_migrate_to_previous_version = (\n        schema(MySchema).field(\"foo\").didnt_exist,\n    )\n</code></pre>"},{"location":"concepts/schema_migrations/#change-a-field-in-the-older-version","title":"Change a field in the older version","text":"<p>The following code allows to set an attribute of a field, such as a description:</p> <pre><code>from cadwyn import VersionChange, schema\n\n\nclass MyChange(VersionChange):\n    description = \"...\"\n    instructions_to_migrate_to_previous_version = (\n        schema(MySchema).field(\"foo\").had(description=\"Foo\"),\n    )\n</code></pre> <p>The following code allows to un-set an attribute of a field, as if it never existed:</p> <pre><code>from cadwyn import VersionChange, schema\n\n\nclass MyChange(VersionChange):\n    description = \"...\"\n    instructions_to_migrate_to_previous_version = (\n        schema(MySchema).field(\"foo\").didnt_have(\"description\"),\n    )\n</code></pre> <p>DEFAULTS WARNING:</p> <p>If you add <code>default</code> or <code>default_factory</code> into the old version of a schema -- it will not manifest in code automatically. Instead, you should add both the <code>default</code> or <code>default_factory</code>, and then also add the default value using a request migration.</p> <p>The reason for such behaviour is the way how Cadwyn works with pydantic and unfortunately this cannot be changed:</p> <p>Cadwyn:</p> <ol> <li>Receives a request for API version <code>V</code></li> <li>Validates the request using the schemas from <code>V</code></li> <li>Marshalls the unmarshalled request body into a raw data structure using <code>BaseModel.dict</code> (<code>BaseModel.model_dump</code> in Pydantic v2) using exclude_unset=True</li> <li>Passes the request through all request migrations from <code>V</code> to <code>latest</code></li> <li>Validates the request using <code>latest</code> schemas</li> </ol> <p>The part that causes the aforementioned problem is cadwyn's usage of <code>exclude_unset=True</code>. Unfortunately, when we use it, all default fields do not get set, so <code>latest</code> does not receive them. And if <code>latest</code> does not have the same defaults (for example, if the field has no default and is required in <code>latest</code>), then an error will occur. If we used <code>exclude_unset=False</code>, then <code>exclude_unset</code> would lose all its purpose for the users of our library so we cannot give it up. Instead, you should set all extras on step 4 in your request migrations.</p>"},{"location":"concepts/schema_migrations/#add-a-validator-to-the-older-version","title":"Add a validator to the older version","text":"<pre><code>from cadwyn import VersionChange, schema\nfrom pydantic import Field, field_validator\n\n\n@field_validator(\"foo\")\ndef validate_foo(cls, value):\n    if not \":\" in value:\n        raise TypeError\n    return value\n\n\nclass MyChange(VersionChange):\n    description = \"...\"\n    instructions_to_migrate_to_previous_version = (\n        schema(MySchema).validator(validate_foo).existed,\n    )\n</code></pre>"},{"location":"concepts/schema_migrations/#remove-a-validator-from-the-older-version","title":"Remove a validator from the older version","text":"<pre><code>from cadwyn import VersionChange, schema\nfrom pydantic import Field, validator\n\n\nclass MyChange(VersionChange):\n    description = \"...\"\n    instructions_to_migrate_to_previous_version = (\n        schema(MySchema).validator(MySchema.validate_foo).didnt_exist,\n    )\n</code></pre>"},{"location":"concepts/schema_migrations/#rename-a-schema-in-the-older-version","title":"Rename a schema in the older version","text":"<p>The following code allows to replace all schema name occurrences with the new one to make sure that the name is different in openapi.json:</p> <pre><code>from cadwyn import VersionChange, schema\n\n\nclass MyChange(VersionChange):\n    description = \"...\"\n    instructions_to_migrate_to_previous_version = (\n        schema(MySchema).had(name=\"OtherSchema\"),\n    )\n</code></pre>"},{"location":"concepts/testing/","title":"Testing","text":"<p>As Cadwyn allows to keep the same business logic, database schemas, etc -- you should have a single set of common tests that test the current latest version. These tests are going to work like the regular tests that you would have if you did not have any API versioning.</p> <p>Here's a possible structure for test files:</p> <pre><code>\u2514\u2500\u2500 tests\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 conftest.py\n    \u251c\u2500\u2500 head\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 conftest.py\n    \u2502   \u251c\u2500\u2500 test_users.py\n    \u2502   \u251c\u2500\u2500 test_admins.py\n    \u2502   \u2514\u2500\u2500 test_invoices.py\n    \u251c\u2500\u2500 v2022_11_16\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 conftest.py\n    \u2502   \u2514\u2500\u2500 test_invoices.py\n    \u2514\u2500\u2500 v2023_03_11\n        \u251c\u2500\u2500 __init__.py\n        \u251c\u2500\u2500 conftest.py\n        \u2514\u2500\u2500 test_users.py\n</code></pre> <p>The following process is recommended when creating a new version:</p> <ol> <li>Before creating a new version, apply the changes you want to your logic and schemas in the latest version (i.e., make the desired breaking changes), and then run the tests in the head directory. The tests that fail indicate the broken contracts</li> <li>Create a new sub-directory in <code>tests</code>, name it after the previous version (e.g., v2024_05_04), and copy only the failing tests into it. Ensure these tests invoke the old version of the API</li> <li>Write a <code>VersionChange</code> that fixes the tests in this outdated version through converters. In the new version, these same tests should still fail</li> <li>Modify the tests in the head directory so that they test the new API contract and pass successfully</li> </ol> <p>This approach helps to keep the old versions covered by tests and to keep the test code duplication minimal.</p>"},{"location":"concepts/version_changes/","title":"Version Changes","text":"<p>Version changes are the backbone of Cadwyn. They allow to describe things like \"This field in that schema had a different name in an older version\" or \"this endpoint did not exist in all earlier versions\".</p> <p>In Cadwyn, your business logic always works with a single version -- HEAD, which is the representation of your latest version. This approach decouples your business logic from versioning and allows you to have hundreds of API versions using the same database models and business logic while staying sane.</p> <p>Follow these steps to add a new version:</p> <ol> <li>Make a breaking change in your HEAD version</li> <li>Reverse it for all your older versions using special \"migration instructions\" so that your current users are not affected by the breaking changes</li> </ol> <p>These migration instructions for reverting the breaking changes are gathered into groups to make them easier to maintain. Let's say you want to rename the <code>creation_date</code> field to <code>created_at</code> but you also want to delete the <code>GET /v1/tax_ids</code> endpoint: these changes are unrelated so they should be placed into different groups.</p> <p>On the other hand, deletion of the <code>POST /v1/tax_ids</code> endpoint should go into the same group as the deletion of <code>GET /v1/tax_ids</code>. These groups are very important to make the changes easily understandable for both your users and your developers.</p> <p>Each such group is called a version change:</p> <pre><code># versions/v2023_02_10.py\n\nfrom cadwyn import VersionChange, endpoint\n\n\nclass RemoveTaxIdEndpoints(VersionChange):\n    description = \"Remove `GET /v1/tax_ids` and `POST /v1/tax_ids` endpoints\"\n    instructions_to_migrate_to_previous_version = (\n        endpoint(\"/v1/tax_ids\", [\"GET\", \"POST\"]).existed,\n    )\n</code></pre> <p>After you have described them, you add your version change class(es) into your version bundle to activate them:</p> <pre><code># versions/__init__.py\n\nfrom cadwyn import HeadVersion, Version, VersionBundle\n\nfrom .v2023_02_10 import RemoveTaxIdEndpoints\n\nversions = VersionBundle(\n    HeadVersion(),\n    Version(\"2023-02-10\", RemoveTaxIdEndpoints),\n    Version(\"2022-11-16\"),\n)\n</code></pre> <p>This instructs Cadwyn to undelete these endpoints in all versions older than 2023-02-10.</p> <p>Now let's discuss what each of these parts does and why:</p>"},{"location":"concepts/version_changes/#versionbundle","title":"VersionBundle","text":"<p><code>VersionBundle</code> is your single source of truth for your list of versions. It contains your list of versions and all version changes associated with them. Each version change is a single group of breaking changes. Each <code>Version</code> contains a group of version changes that caused this version to be created. For example, if I delete the <code>POST /v1/tax_ids</code> endpoint in version <code>2023-02-10</code>, then I'll add a version change for deleting that endpoint into <code>2023-02-10</code>. For example:</p> <pre><code># versions/__init__.py\n\nfrom cadwyn import HeadVersion, Version, VersionBundle\n\nfrom .v2023_02_10 import RemoveTaxIdEndpoints\n\nversions = VersionBundle(\n    HeadVersion(),\n    Version(\"2023-02-10\", RemoveTaxIdEndpoints),\n    Version(\"2022-11-16\"),\n)\n</code></pre> <p>Did you notice that the first version <code>2022-11-16</code> does not have any version changes? That is intentional! How can it have breaking changes if there are no prior versions before it?</p>"},{"location":"concepts/version_changes/#version","title":"Version","text":"<p><code>Version</code> is simply an ordered collection of version changes that allows to describe when each version change happened so that Cadwyn is able to generate your schemas and routes for all versions correctly, based on which version changes are located in which versions.</p>"},{"location":"concepts/version_changes/#headversion","title":"HeadVersion","text":"<p>Cadwyn has a special HEAD version: it is the only version you will create manually and use directly in your business logic. It is also the version that is used by Cadwyn for generating all other versions.</p> <p>When handling an HTTP request, Cadwyn first validates it with the appropriate API version, then Cadwyn applies all converters from the request's API version and up to the latest API version to it, and then finally Cadwyn converts the request to the appropriate schema from HEAD version (the schema that was used for generating the versioned schema from request's API version).</p> <p>So Cadwyn migrates all requests from all versions to HEAD version to make sure that your business logic operates with only one version.</p> <p>HEAD is very similar to your latest version but for a few key differences:</p> <ul> <li>Latest is user-facing while HEAD is only used internally by you and Cadwyn</li> <li>Latest is generated while HEAD is maintained by you manually</li> <li>Latest only includes the fields that our user is supposed to see in the latest version while HEAD can include some fields missing from latest. For example, if an earlier version contained a field completely incompatible with latest, HEAD will have it too to make sure that old versions can function the same as before. This also applies to field types: if a field is required in latest but was nullable in an earlier version, then HEAD will have it as nullable to make sure that any earlier version request can easily be converted into a HEAD request</li> <li>Latest can include constraints that are incompatible with older versions while HEAD can contain no constraints at all if you want -- the user-facing schemas are applied for validation before the request is converted to HEAD so HEAD does not need to re-validate anything if you do not want it to</li> </ul>"},{"location":"concepts/version_changes/#versionchange","title":"VersionChange","text":"<p><code>VersionChange</code> classes describe each atomic group of business capabilities that you have altered in a version.</p> <p>Note, however, that you only need to have a migration if it is a breaking change for your users. If you add a new endpoint or add a new field to your response schema, you do not need to have a migration for it because your users' code will not break. So by not having a migration you automatically add this change to all versions.</p>"},{"location":"concepts/version_changes/#versionchange__name__","title":"VersionChange.__name__","text":"<p>The name of a version change, for example <code>RemoveTaxIdEndpoints</code>, describes what breaking change has happened. It must be a verb and it is the best clue for your new developers to quickly understand what happened between the versions. Feel free to use long names: it is better to have a long name than a name that fails to convey what exactly happened. Better have a voluminous name such as <code>RenameCreationDatetimeAndUpdateDatetimeToCreatedAtAndUpdatedAt</code> than to have a generic name such as <code>RefactorFields</code>. Because after just a few of such version changes your versioning structure can become completely unreadable:</p> <pre><code>versions = VersionBundle(\n    Version(\"2023-05-09\", ChangeCreateLogic, AddRequiredFields),\n    Version(\"2023-04-02\", DeleteEndpoint, ChangeFields, RenameFields),\n    Version(\"2023-02-10\", RenameEndpoints, RefactorFields),\n    Version(\"2022-11-16\"),\n)\n</code></pre>"},{"location":"concepts/version_changes/#versionchangedescription","title":"VersionChange.description","text":"<p>The description field of your version change must be even more detailed. In fact, it is intended to be the name and the summary of the version change for your clients. It must clearly state to you clients what happened and why. So you need to make it grammatically correct, detailed, specific, and written for humans. Note that you do not have to use a strict machine-readable format -- it is a portion of documentation, not a set of instructions. Let's take Stripe's description to one of their version changes as an example:</p> <pre><code>Event objects (and webhooks) will now render a `request` subobject that contains a request Id and idempotency key instead of just a string request Id.\n</code></pre> <p>It is concise, descriptive, and human-readable -- just like any good documentation. Now let's have a look at a bad description:</p> <pre><code>Migration from first version (2022-11-16) to 2023-09-01 version.\nChanges:\n* Changed schema for 'POST /v1/tax_ids' endpoint\n</code></pre> <ul> <li>Its first line, <code>Migration from first version (2022-11-16) to 2023-09-01 version.</code>, duplicates the already-known information -- your developers will know which version <code>VersionChange</code> migrates to and from by its location in VersionBundle and most likely by its file name. So it is redundant information</li> <li>Its second line, <code>Changes:</code>, does not provide useful information either because description of a <code>VersionChange</code> cannot describe anything but changes. So again, it is redundant information</li> <li>Its third line, <code>Changed schema for 'POST /v1/tax_ids' endpoint</code>, gives both too much and too little information. It states changing of a schema but it does not mention what exactly was changed. The goal is to make it easy for our clients to migrate from one version to another. The recommended description here is to mention the OpenAPI model name that you changed, the fields you changed, and why you changed them</li> </ul>"},{"location":"concepts/version_changes/#versionchangeinstructions_to_migrate_to_previous_version","title":"VersionChange.instructions_to_migrate_to_previous_version","text":"<p>In Cadwyn, you use the latest version. This attribute is a way for you to describe how your schemas and endpoints looked in previous versions so that Cadwyn can guess schema and route generation to recreate the old schemas and endpoints for your clients. So you only need to maintain your head (latest) schemas and your migrations while Cadwyn takes care of the rest. In fact, you spend minimal effort on maintaining your migrations because they are effectively immutable -- they describe the breaking changes that happened in the past so there is no need to ever change them.</p> <p>This approach of maintaining the present and describing the past might appear weird. You just need to form the correct mindset which is counter-intuitive at first but after just one or two attempts at versioning you will see how much sense this approach makes.</p> <p>Imagine you needed to know what your code looked like two weeks ago. You would use <code>git checkout</code> or <code>git reset</code> with an older commit because <code>git</code> stores the latest version of your code (which is also called HEAD) and the diffs between it and each previous version as a chain of changes. This is exactly how Cadwyn works! We store the latest version and use the diffs to regenerate the older versions.</p> Note to curious readers    Git doesn't actually work this way internally. My description is closer to how SVN works. It is just a really simplistic metaphor to explain a concept."},{"location":"concepts/version_changes/#data-migrations","title":"Data migrations","text":"<p>Let's say we renamed the field <code>creation_date</code> to <code>created_at</code>. We have altered our schemas -- that's great! But when our clients send us requests using the old versions of our API -- we will still get the data where we have <code>creation_date</code> instead of <code>created_at</code>. How do we solve this? Well, in Cadwyn your business logic never receives requests of the old versions. Instead, it receives only the requests of the latest version. So when you define a version change that renames a field, you need to also define how to convert the request body from the old version to the newer version. For example:</p> <pre><code>from cadwyn import (\n    RequestInfo,\n    VersionChange,\n    convert_request_to_next_version_for,\n    schema,\n)\nfrom invoices import InvoiceCreateRequest\n\n\nclass RemoveTaxIdEndpoints(VersionChange):\n    description = \"Rename `Invoice.creation_date` to `Invoice.created_at`.\"\n    instructions_to_migrate_to_previous_version = (\n        schema(InvoiceCreateRequest)\n        .field(\"creation_date\")\n        .had(name=\"created_at\"),\n    )\n\n    @convert_request_to_next_version_for(InvoiceCreateRequest)\n    def rename_creation_date_to_created_at(request: RequestInfo):\n        request.body[\"created_at\"] = request.body.pop(\"creation_date\")\n</code></pre> <p>Did you notice how the schema for <code>InvoiceCreateRequest</code> is specified in our migration? This will signal to Cadwyn to apply it to all routes that have this schema as their body.</p> <p>Now we have not only described how schemas changed but we have also described how to migrate a request of the old version to the new version. When Cadwyn receives a request targeting a particular version, the request is first validated against the schema of that particular version. Then Cadwyn applies all request migrations until the latest version to migrate the request to latest. So now your business logic receives the latest version of the request yet for your clients you have two versions of your API -- you have added variability without introducing any complexity into your business logic.</p> <p>But wait... What happens to the <code>Invoice</code> responses? Your business logic will now return <code>created_at</code> so your clients from old versions will be affected! Cadwyn has a tool for that too: we migrate our responses as well. Requests were migrated forward in versions but responses are migrated backward in versions! So your business logic returns a response of the latest version and Cadwyn will use your response migrations to migrate it back to the version of your client's request:</p> <pre><code>from cadwyn import (\n    RequestInfo,\n    ResponseInfo,\n    VersionChange,\n    convert_request_to_next_version_for,\n    convert_response_to_previous_version_for,\n    schema,\n)\nfrom invoices import (\n    BaseInvoice,\n    InvoiceCreateRequest,\n    InvoiceResource,\n)\n\n\nclass RemoveTaxIdEndpoints(VersionChange):\n    description = \"Rename `Invoice.creation_date` to `Invoice.created_at`.\"\n    instructions_to_migrate_to_previous_version = (\n        schema(BaseInvoice).field(\"creation_date\").had(name=\"created_at\"),\n    )\n\n    @convert_request_to_next_version_for(InvoiceCreateRequest)\n    def rename_creation_date_to_created_at(request: RequestInfo):\n        request.body[\"created_at\"] = request.body.pop(\"creation_date\")\n\n    @convert_response_to_previous_version_for(InvoiceResource)\n    def rename_created_at_to_creation_date(response: ResponseInfo):\n        response.body[\"creation_date\"] = response.body.pop(\"created_at\")\n</code></pre> <p>Did you notice how the schema for <code>InvoiceResource</code> is specified in our migration? This will signal to Cadwyn to apply it to all routes that have this schema as their <code>response_model</code>. Notice also that we now use <code>BaseInvoice</code> in our instructions -- let's imagine that it is the parent of both <code>InvoiceCreateRequest</code> and <code>InvoiceResource</code> so renaming it there will rename it in these schemas as well. You can, however, apply the instructions to both individual schemas instead of their parent if you want to.</p> <p>Now our request comes, Cadwyn migrates it to the latest version using our request migration, then we do our business logic, return the latest response from it, and Cadwyn migrates it back to the request version. Does our business logic or database know about the fact that we have two versions? No, not at all! It is zero-cost. Imagine how beneficial it is when you support not two but two hundred versions.</p> <p></p> <p>Notice how we used the latest versions of our schemas in our migration -- this pattern can be found everywhere in Cadwyn. The latest version of your schemas is used to describe what happened to all other versions because other versions might not exist when you are defining migrations for them.</p>"},{"location":"concepts/version_changes/#path-based-migration-specification","title":"Path-based migration specification","text":"<p>Oftentimes you need to migrate based on the endpoint path rather than the request body or response model. This happens when, for example, endpoint does not have a request body or its response model is used in other places that we do not want to migrate. Consider the example above, but use paths instead of schemas:</p> <pre><code>from cadwyn import (\n    RequestInfo,\n    ResponseInfo,\n    VersionChange,\n    convert_request_to_next_version_for,\n    convert_response_to_previous_version_for,\n    schema,\n)\nfrom invoices import BaseInvoice\n\n\nclass RemoveTaxIdEndpoints(VersionChange):\n    description = \"Rename `Invoice.creation_date` to `Invoice.created_at`.\"\n    instructions_to_migrate_to_previous_version = (\n        schema(BaseInvoice).field(\"creation_date\").had(name=\"created_at\"),\n    )\n\n    @convert_request_to_next_version_for(\"/v1/invoices\", [\"POST\"])\n    def rename_creation_date_to_created_at(request: RequestInfo):\n        request.body[\"created_at\"] = request.body.pop(\"creation_date\")\n\n    @convert_response_to_previous_version_for(\"/v1/invoices\", [\"GET\"])\n    def rename_created_at_to_creation_date(response: ResponseInfo):\n        response.body[\"creation_date\"] = response.body.pop(\"created_at\")\n</code></pre> <p>Though I highly recommend you to stick to schemas as it is much easier to introduce inconsistencies when using paths; for example, when you have 10 endpoints with the same response body schema but you forgot to add migrations for 3 of them because you use paths instead of schemas.</p>"},{"location":"concepts/version_changes/#migration-of-http-errors","title":"Migration of HTTP errors","text":"<p>Oftentimes you need to raise <code>fastapi.HTTPException</code> in your code to signal some errors to your users. However, if you want to change the status code of some error, it would be a breaking change because your error status codes and sometimes even their bodies are a part of your API contract.</p> <p>By default, Cadwyn's response migrations do not handle errors but you can use the <code>migrate_http_errors</code> keyword argument to enable it:</p> <pre><code>from cadwyn import (\n    ResponseInfo,\n    VersionChange,\n    convert_response_to_previous_version_for,\n)\n\n\nclass RemoveTaxIdEndpoints(VersionChange):\n    description = \"Change status code in 'GET /v1/invoices' when invoice was not found from 400 to 404\"\n    instructions_to_migrate_to_previous_version = ()\n\n    @convert_response_to_previous_version_for(\n        \"/v1/invoices\", [\"GET\"], migrate_http_errors=True\n    )\n    def change_400_to_404(response: ResponseInfo):\n        if response.status_code == 400:\n            response.status_code = 404\n</code></pre>"},{"location":"concepts/version_changes/#migration-of-non-body-attributes","title":"Migration of non-body attributes","text":"<p>Cadwyn can migrate more than just request bodies.</p> <p><code>RequestInfo</code> has the following interfaces to migrate requests:</p> <ul> <li><code>body: Any</code></li> <li><code>headers: starlette.datastructures.MutableHeaders</code></li> <li><code>cookies: dict[str, str]</code></li> <li><code>query_params: dict[str, str]</code></li> </ul> <p><code>ResponseInfo</code> has the the following interfaces to migrate responses:</p> <ul> <li><code>body: Any</code></li> <li><code>status_code: int</code></li> <li><code>headers: starlette.datastructures.MutableHeaders</code></li> <li>set_cookie</li> <li>delete_cookie</li> </ul>"},{"location":"concepts/version_changes/#internal-representations","title":"Internal representations","text":"<p>We have only reviewed simplistic cases so far. But what happens when you cannot just migrate your data that easily? It can happen because your earlier versions had more data than your newer versions. Or that data had more formats.</p> <p>Let's imagine that previously the <code>User</code> schema had a list of addresses but now we want to make a breaking change and turn them into a single address. The naive migration will just take the first address from the list for requests and turn that one address into a list for responses like so:</p> <pre><code>from cadwyn import (\n    RequestInfo,\n    ResponseInfo,\n    VersionChange,\n    convert_request_to_next_version_for,\n    convert_response_to_previous_version_for,\n    schema,\n)\nfrom users import BaseUser\n\n\n# THIS IS AN EXAMPLE OF A BAD MIGRATION\nclass RemoveTaxIdEndpoints(VersionChange):\n    description = \"Users now have `address` field instead of `addresses`\"\n    instructions_to_migrate_to_previous_version = (\n        schema(BaseUser).field(\"address\").didnt_exist,\n        schema(BaseUser).field(\"addresses\").existed_as(type=list[str]),\n    )\n\n    @convert_request_to_next_version_for(BaseUser)\n    def turn_addresses_into_a_single_item(request: RequestInfo):\n        addresses = request.body.pop(\"addresses\")\n        # The list could have been empty in the past so new \"address\"\n        # field must be nullable.\n        request.body[\"address\"] = addresses[0] if addresses else None\n\n    @convert_response_to_previous_version_for(BaseUser)\n    def turn_address_into_a_list(response: ResponseInfo):\n        response.body[\"addresses\"] = [response.body.pop(\"address\")]\n</code></pre> <p>But this will not work. Now when the user from the old version asks us to save three addresses, we will in fact save only one. Old data is also going to be affected -- if old users had multiple addresses, we will only be able to return one of them. This is bad -- we have made a breaking change!</p> <p>In order to solve this issue, Cadwyn uses a concept of internal representations. An internal representation of your data is like a database entry of your data -- it is its latest version plus all the fields that are incompatible with the latest API version. If we were talking about classes, then internal representation would be a child of your latest schemas -- it has all the same data and a little more, it expands its functionality. Essentially your internal representation of user object can contain much more data than your latest schemas.</p> <p>So all your requests get migrated to HEAD, which is the internal representation of latest -- but not exactly the latest itself. So its data is really similar to latest. Same happens to your responses -- you do not respond with and migrate from the latest version of your data, you respond with its internal representation which is really close to the actual latest schemas.</p> <p>In responses, returning the internal representation is simple: just return your database model or a dict with everything you need for all your versions. In the user address example, we would continue storing the list of addresses in our database but then add the single address to our response. Latest schemas will simply strip it but our older schemas will be able to use it!</p> <pre><code># in your business logic\n\nreturn {\"address\": user.addresses[0] if user.addresses else None, **user}\n</code></pre> <p>So now your migration will look like the following:</p> <pre><code>from cadwyn import VersionChange, schema\nfrom users import User\n\n\nclass RemoveTaxIdEndpoints(VersionChange):\n    description = \"Users now have `address` field instead of `addresses`\"\n    instructions_to_migrate_to_previous_version = (\n        schema(User).field(\"address\").didnt_exist,\n        schema(User).field(\"addresses\").existed_as(type=list[str]),\n    )\n</code></pre> <p>Yes, we do not need any of the migrations anymore because responses are handled automatically. See how-to section for an example of how we would achieve the same feat for requests.</p>"},{"location":"concepts/version_changes/#manual-body-migrations","title":"Manual body migrations","text":"<p>Oftentimes you will have a need to migrate your data outside of routing, manually. For example, when you need to send a versioned response to your client via webhook or inside a worker/cronjob. In these instances, you can use <code>cadwyn.VersionBundle.migrate_response_body</code>:</p> <pre><code>from users import UserResource\nfrom versions import version_bundle\n\nbody_from_2000_01_01 = version_bundle.migrate_response_body(\n    UserResource, latest_body={\"name\": \"John\"}, version=\"2000-01-01\"\n)\n</code></pre> <p>The returned <code>body_from_2000_01_01</code> is your data passed through all converters (similar to how it would when a response is returned from your route) and wrapped into <code>data.v2000_01_01.UserResource</code>. Because it is wrapped, we can include Pydantic\u2019s defaults.</p>"},{"location":"concepts/version_changes/#streamingresponse-and-fileresponse-migrations","title":"StreamingResponse and FileResponse migrations","text":"<p>Migrations for the bodies of <code>fastapi.responses.StreamingResponse</code> and <code>fastapi.responses.FileResponse</code> are not directly supported yet (1, 2). However, you can use <code>ResponseInfo._response</code> attribute to get access to the original <code>StreamingResponse</code> or <code>FileResponse</code> and modify it in any way you wish within your migrations.</p>"},{"location":"concepts/version_changes/#pydantic-rootmodel-migration-warning","title":"Pydantic RootModel migration warning","text":"<p>Pydantic has an interesting implementation detail: <code>pydantic.RootModel</code> instances are memoized. So the following code is going to output <code>True</code>:</p> <pre><code>from pydantic import RootModel\nfrom users import User\n\nBulkCreateUsersRequestBody = RootModel[list[User]]\nBulkCreateUsersResponseBody = RootModel[list[User]]\n\nprint(BulkCreateUsersRequestBody is BulkCreateUsersResponseBody)  # True\n</code></pre> <p>So if you make a migration that should only affect one of these schemas -- it will automatically affect both. A recommended alternative is to either use subclassing:</p> <pre><code>from pydantic import RootModel\nfrom users import User\n\nUserList = RootModel[list[User]]\n\n\nclass BulkCreateUsersRequestBody(UserList):\n    pass\n\n\nclass BulkCreateUsersResponseBody(UserList):\n    pass\n\n\nprint(BulkCreateUsersRequestBody is BulkCreateUsersResponseBody)  # False\n</code></pre> <p>or to specify migrations using endpoint path instead of a schema.</p>"},{"location":"concepts/version_changes/#dependency-re-execution-warning","title":"Dependency re-execution warning","text":"<p>Notice that whenever a request reaches Cadwyn, it is first validated against the request's version of the schema, then we migrate it to the latest version, and then validate again to prevent migrations from creating invalid requests.</p> <p>This means that if you have a dependency that is executed during the request validation, it will be executed twice. For example, if you have a dependency that checks whether a user exists in the database, it will be executed twice. This is not an issue if the dependency is idempotent, but it becomes one if it is not.</p> <p>To solve this issue, you can use the <code>cadwyn.current_dependency_solver</code> dependency which tells you whether your dependency is getting called before or after the request is migrated. If you want to run it once we migrated the request to the latest version, you should only run it when <code>current_dependency_solver</code> is <code>\"cadwyn\"</code>. If you want your dependency to run at the very beginning of handling the request, you should only run it when <code>current_dependency_solver</code> is <code>\"fastapi\"</code>.</p> <pre><code>from cadwyn import current_dependency_solver\n\n\ndef my_dependency(\n    dependency_solver: Annotated[\n        Literal[\"fastapi\", \"cadwyn\"], Depends(current_dependency_solver)\n    ]\n):\n    if dependency_solver == \"fastapi\":  # Before migration\n        ...\n    else:  # After migration\n        ...\n</code></pre> <p>but the majority of your dependencies will not need this as most dependencies should not have side effects or network calls within them.</p>"},{"location":"concepts/version_changes/#version-changes-with-side-effects","title":"Version changes with side effects","text":"<p>Sometimes you will use API versioning to handle a breaking change in your business logic, not in the schemas themselves. In such cases, it is tempting to add a version check and just follow the new business logic such as:</p> <pre><code># This is wrong. Please, do not do this.\nif api_version_var.get() &gt;= date(2022, 11, 11):\n    # do new logic here\n    ...\n</code></pre> <p>Instead, Cadwyn provides a special <code>VersionChangeWithSideEffects</code> class for handling such cases. It makes finding dangerous versions that have side effects much easier and provides a nice abstraction for checking whether we are on a version where these side effects have been applied.</p> <p>As an example, let's use the tutorial section's case with the user and their address. Let's say we use an external service to check whether user's address is listed in it and return 400 response if it is not. Let's also say that we only added this check in the newest version.</p> <pre><code>from cadwyn import VersionChangeWithSideEffects\n\n\nclass UserAddressIsCheckedInExternalService(VersionChangeWithSideEffects):\n    description = (\n        \"User's address is now checked for existence in an external service. \"\n        \"If it doesn't exist there, a 400 code is returned.\"\n    )\n</code></pre> <p>Then we will have the following check in our business logic:</p> <pre><code>from src.versions import versions, UserAddressIsCheckedInExternalService\n\n\nasync def create_user(payload):\n    if UserAddressIsCheckedInExternalService.is_applied:\n        check_user_address_exists_in_an_external_service(payload.address)\n    ...\n</code></pre> <p>So this change can be contained in any version -- your business logic doesn't know which version it has and shouldn't.</p>"},{"location":"concepts/version_changes/#warning-against-side-effects","title":"Warning against side effects","text":"<p>Side effects are a very powerful tool but they must be used with great caution. Are you sure you MUST change your business logic? Are you sure whatever you are trying to do cannot just be done by a migration? 90% of time, you will not need them. Please, think twice before using them. API Versioning is about having the same underlying app and data while just changing the schemas and api endpoints to interact with it. By introducing side effects, you leak versioning into your business logic and possibly even your data which makes your code significantly harder to maintain in the long term. If each side effect adds a single <code>if</code> to your logic, then after 100 versions with side effects, you will have 100 more <code>if</code>s. If used correctly, Cadwyn helps you maintain decades\u2019 worth of API versions with minimal maintenance effort, and side effects make it significantly harder to do. Changes in the underlying source, structure, or logic of your data should not affect your API or public-facing business logic.</p> <p>However, the following use cases often necessitate side effects.</p>"},{"location":"home/CHANGELOG/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file. Please follow the Keep a Changelog standard.</p>"},{"location":"home/CHANGELOG/#unreleased","title":"[Unreleased]","text":""},{"location":"home/CHANGELOG/#544","title":"[5.4.4]","text":""},{"location":"home/CHANGELOG/#fixed","title":"Fixed","text":"<ul> <li>Fixed KeyError when versioning Pydantic models containing ClassVar annotations</li> </ul>"},{"location":"home/CHANGELOG/#543","title":"[5.4.3]","text":""},{"location":"home/CHANGELOG/#fixed_1","title":"Fixed","text":"<ul> <li>XSS vulnerability in <code>/docs</code> and <code>/redoc</code> endpoints where the <code>version</code> parameter was not properly sanitized, allowing potential cross-site scripting attacks</li> </ul>"},{"location":"home/CHANGELOG/#542","title":"[5.4.2]","text":""},{"location":"home/CHANGELOG/#fixed_2","title":"Fixed","text":"<ul> <li>Added support for computed fields</li> </ul>"},{"location":"home/CHANGELOG/#541","title":"[5.4.1]","text":""},{"location":"home/CHANGELOG/#fixed_3","title":"Fixed","text":"<ul> <li>Fixed import error in python 3.9 when using typing_extensions==3.14.0</li> </ul>"},{"location":"home/CHANGELOG/#540","title":"[5.4.0]","text":""},{"location":"home/CHANGELOG/#added","title":"Added","text":"<ul> <li><code>typing_inspection</code> dependency from pydantic team for complex isinstance checks that must be the same between <code>typing</code> and <code>typing_extensions</code></li> <li>Support for <code>pydantic&gt;=2.12.0</code> FieldInfo refactoring from https://github.com/pydantic/pydantic/pull/11898</li> </ul>"},{"location":"home/CHANGELOG/#533","title":"[5.3.3]","text":""},{"location":"home/CHANGELOG/#fixed_4","title":"Fixed","text":"<ul> <li>Fixed pypi badge link in README</li> </ul>"},{"location":"home/CHANGELOG/#532","title":"[5.3.2]","text":""},{"location":"home/CHANGELOG/#fixed_5","title":"Fixed","text":"<ul> <li>Add support for <code>pydantic_settings.BaseSettings</code> in dependencies</li> </ul>"},{"location":"home/CHANGELOG/#531","title":"[5.3.1]","text":""},{"location":"home/CHANGELOG/#fixed_6","title":"Fixed","text":"<ul> <li>Fix invalid content-length header with custom exception handlers (#273)</li> </ul>"},{"location":"home/CHANGELOG/#530","title":"[5.3.0]","text":""},{"location":"home/CHANGELOG/#added_1","title":"Added","text":"<ul> <li><code>api_version_title</code> and <code>api_version_description</code> arguments to <code>Cadwyn</code> to allow customizing the API version parameter in the OpenAPI schema</li> </ul>"},{"location":"home/CHANGELOG/#522","title":"[5.2.2]","text":""},{"location":"home/CHANGELOG/#fixed_7","title":"Fixed","text":"<ul> <li>Whenever a route was migrated by path, we used the path and methods of the request. So if the request wanted \"/v1/webhook_settings\" and we renamed them to \"/v1/webhook_subscriptions\" -- all migrations for \"/v1/webhook_subscriptions\" would not get applied to any requests that wanted \"/v1/webhook_settings\". This effectively means that previously route renamings were incompatible with by path converters. Now we use the head route id instead of the path and methods of the request for matching so we always know which migrations to apply.</li> </ul>"},{"location":"home/CHANGELOG/#521","title":"[5.2.1]","text":""},{"location":"home/CHANGELOG/#fixed_8","title":"Fixed","text":"<ul> <li>#268 A bug where we received 404 for all unversioned routes when a default api version was passed to Cadwyn at initialization</li> </ul>"},{"location":"home/CHANGELOG/#520","title":"[5.2.0]","text":""},{"location":"home/CHANGELOG/#removed","title":"Removed","text":"<ul> <li><code>issubclass</code> dependency</li> </ul>"},{"location":"home/CHANGELOG/#514","title":"[5.1.4]","text":""},{"location":"home/CHANGELOG/#fixed_9","title":"Fixed","text":"<ul> <li>a bug where a custom HTTP exception was not being copied correctly so its unique properties are ignored</li> </ul>"},{"location":"home/CHANGELOG/#513","title":"[5.1.3]","text":""},{"location":"home/CHANGELOG/#fixed_10","title":"Fixed","text":"<ul> <li><code>__doc__</code> attribute is now copied from the original enum to the generated enum</li> <li>Python 3.12 type aliases and their typing_extensions backports are now supported (including <code>pydantic.JsonValue</code> and other <code>typing_extensions.TypeAliasType</code> instances)</li> <li>The bug when solve_dependencies error on the migration of a request to the latest version responds with a non-json serializable error and cadwyn showed a failed to serialize error instead of the actual error</li> <li>Updated minimum FastAPI version to 0.112.4 because embed_body_fields was added in 0.112.4</li> </ul>"},{"location":"home/CHANGELOG/#512","title":"[5.1.2]","text":""},{"location":"home/CHANGELOG/#fixed_11","title":"Fixed","text":"<ul> <li>Generators not being called when FastAPI validates the initial request</li> </ul>"},{"location":"home/CHANGELOG/#added_2","title":"Added","text":"<ul> <li><code>cadwyn.current_dependency_solver</code> function to check whether cadwyn or FastAPI is currently solving dependencies. It can be used as a dependency for versioned endpoints like so: <code>current_dependency_solver: Annotated[Literal[\"fastapi\", \"cadwyn\"], Depends(current_dependency_solver)]</code>. If your dependency has side effects, you would likely want to only run it once per request. If you want to run it once we migrated the request to the latest version, you should only run it when <code>current_dependency_solver</code> is <code>\"cadwyn\"</code>. If you want your dependency to run at the very beginning of handling the request, you should only run it when <code>current_dependency_solver</code> is <code>\"fastapi\"</code>.</li> </ul>"},{"location":"home/CHANGELOG/#511","title":"[5.1.1]","text":""},{"location":"home/CHANGELOG/#fixed_12","title":"Fixed","text":"<ul> <li>Support for <code>WithJsonSchema</code> in schema generation</li> </ul>"},{"location":"home/CHANGELOG/#510","title":"[5.1.0]","text":""},{"location":"home/CHANGELOG/#added_3","title":"Added","text":"<ul> <li>Support for python 3.9</li> </ul>"},{"location":"home/CHANGELOG/#500","title":"[5.0.0]","text":""},{"location":"home/CHANGELOG/#added_4","title":"Added","text":"<ul> <li>Support for URL path version prefixes instead of version headers. You can control it with the <code>api_version_location</code> argument of <code>cadwyn.Cadwyn</code>.</li> <li>Support for arbitrary strings as versions. You can control the format of the version with the <code>api_version_format</code> argument of <code>cadwyn.Cadwyn</code>.</li> <li>Extensibility of version picking logic with a new <code>VersionPickingMiddleware</code> class that you can pass to the <code>versioning_middleware_class</code> argument of <code>cadwyn.Cadwyn</code>.</li> <li><code>api_version_default_value</code> argument to <code>cadwyn.Cadwyn</code> to set a default version for unversioned requests. It can be a string or an async callable that returns a string.</li> </ul>"},{"location":"home/CHANGELOG/#changed","title":"Changed","text":"<ul> <li><code>cadwyn.Version</code>, <code>cadwyn.VersionBundle</code>, and <code>cadwyn.VersionBundle.api_version_var</code> now store versions as strings instead of dates. Date types can still be passed to <code>cadwyn.Version</code> but there is no guarantee that they will be supported in the future. However, ISO dates with a string type are guaranteed to be supported.</li> <li>Cadwyn's <code>api_version_header_name</code> argument is now deprecated in favor of <code>api_version_parameter_name</code></li> <li><code>cadwyn.Cadwyn.add_header_versioned_routers</code> method is now deprecated in favor of <code>cadwyn.Cadwyn.generate_and_include_versioned_routers</code>. It will be removed in version 6.0.0</li> </ul>"},{"location":"home/CHANGELOG/#removed_1","title":"Removed","text":"<ul> <li><code>HeaderVersioningMiddleware</code> in favor of <code>VersionPickingMiddleware</code> because we now support more than just headers</li> </ul>"},{"location":"home/CHANGELOG/#460","title":"[4.6.0]","text":""},{"location":"home/CHANGELOG/#added_5","title":"Added","text":"<ul> <li>Support for more field attributes in <code>schema.had()</code> and <code>schema.didnt_have()</code>: <code>field_title_generator</code>, <code>fail_fast</code>, <code>coerce_numbers_to_str</code>, <code>union_mode</code>, <code>allow_mutation</code>, <code>pattern</code>, <code>discriminator</code></li> <li>Support for forwardrefs in body fields (for example, when you use <code>from __future__ import annotations</code> in the file with your routes)</li> <li>Support for forwardrefs in route dependencies</li> </ul>"},{"location":"home/CHANGELOG/#450","title":"[4.5.0]","text":""},{"location":"home/CHANGELOG/#added_6","title":"Added","text":"<ul> <li><code>check_usage</code> argument to request/response by schema converters. Cadwyn always checks whether a schema mentioned in a converter applies to one or more endpoints to guarantee that the converter will apply to at least one endpoint. Sometimes, however, you do not need this validation. For example, when you use these converters for converting webhook bodies. Setting <code>check_usage=False</code> makes it possible to skip the validation</li> </ul>"},{"location":"home/CHANGELOG/#445","title":"[4.4.5]","text":""},{"location":"home/CHANGELOG/#fixed_13","title":"Fixed","text":"<ul> <li>Fix invalid migration of pydantic v1 style root validators when pydantic erases information about their \"skip_on_failure\" attribute</li> </ul>"},{"location":"home/CHANGELOG/#444","title":"[4.4.4]","text":""},{"location":"home/CHANGELOG/#fixed_14","title":"Fixed","text":"<ul> <li>Type hints for newest pydantic versions</li> </ul>"},{"location":"home/CHANGELOG/#443","title":"[4.4.3]","text":""},{"location":"home/CHANGELOG/#changed_1","title":"Changed","text":"<ul> <li>Bumped package versions</li> </ul>"},{"location":"home/CHANGELOG/#442","title":"[4.4.2]","text":""},{"location":"home/CHANGELOG/#fixed_15","title":"Fixed","text":"<ul> <li>Non-function (object instances) dependencies not supporting dependency overrides in testing</li> </ul>"},{"location":"home/CHANGELOG/#441","title":"[4.4.1]","text":""},{"location":"home/CHANGELOG/#added_7","title":"Added","text":"<ul> <li>Python 3.13 to CI</li> </ul>"},{"location":"home/CHANGELOG/#440","title":"[4.4.0]","text":""},{"location":"home/CHANGELOG/#added_8","title":"Added","text":"<ul> <li>Support for webhooks in swagger</li> <li>Automatic generation of versioned routes and webhooks upon the first request to Cadwyn. Notice that if you were using some of cadwyn's internal interfaces, this might break your code. If it did, make an issue and let's discuss your use case</li> </ul>"},{"location":"home/CHANGELOG/#431","title":"[4.3.1]","text":""},{"location":"home/CHANGELOG/#fixed_16","title":"Fixed","text":"<ul> <li>Removed typer from main dependencies</li> </ul>"},{"location":"home/CHANGELOG/#430","title":"[4.3.0]","text":""},{"location":"home/CHANGELOG/#changed_2","title":"Changed","text":"<ul> <li>Migrated from poetry to uv (Contributed by @bastienpo)</li> <li>Removed CLI and Uvicorn dependencies from Cadwyn installations by default. Added a <code>standard</code> extras group to mirror FastAPI (Contributed by @bastienpo)</li> </ul>"},{"location":"home/CHANGELOG/#424","title":"[4.2.4]","text":""},{"location":"home/CHANGELOG/#fixed_17","title":"Fixed","text":"<ul> <li>Background tasks not functioning in versioned endpoints</li> </ul>"},{"location":"home/CHANGELOG/#423","title":"[4.2.3]","text":""},{"location":"home/CHANGELOG/#fixed_18","title":"Fixed","text":"<ul> <li>Added support for <code>embed_body_fields</code> in <code>solve_dependencies</code> and <code>create_model_field</code> in FastAPI. FastAPI has made a breaking change for these interfaces which is why we had to fix it</li> <li>Fixed invalid imports in quickstart docs</li> <li>Fixed default dependencies not including the CLI for FastAPI, thus causing the quickstart docs to be invalid</li> </ul>"},{"location":"home/CHANGELOG/#422","title":"[4.2.2]","text":""},{"location":"home/CHANGELOG/#fixed_19","title":"Fixed","text":"<ul> <li>FastAPI Servers list did not include root path when mounted as a sub-app unless specified directly within the user defined server list (Contributed by @OD-tpeko)</li> <li>OpenAPI spec did not include the <code>summary</code> field (Contributed by @OD-tpeko)</li> </ul>"},{"location":"home/CHANGELOG/#421","title":"[4.2.1]","text":""},{"location":"home/CHANGELOG/#fixed_20","title":"Fixed","text":"<ul> <li>Previously the docs were showing wrong versioned doc paths when cadwyn was mounted as a sub-app (Contributed by @OD-tpeko)</li> </ul>"},{"location":"home/CHANGELOG/#420","title":"[4.2.0]","text":""},{"location":"home/CHANGELOG/#added_9","title":"Added","text":"<ul> <li>Automatic changelog generation from version changes using <code>Cadwyn.generate_changelog</code> method and <code>GET /changelog</code> endpoint.</li> <li>Automatic creation of versioned_routers based on the <code>VersionBundle</code> passed to <code>Cadwyn</code> which means that all versions mentioned in the version bundle will already be available for routing even without the use of <code>generate_and_include_versioned_routers</code></li> </ul>"},{"location":"home/CHANGELOG/#changed_3","title":"Changed","text":"<ul> <li>Renamed <code>Version.version_changes</code> to <code>Version.changes</code></li> </ul>"},{"location":"home/CHANGELOG/#removed_2","title":"Removed","text":"<ul> <li><code>regex</code>, <code>include</code>, <code>min_items</code>, <code>max_items</code>, and <code>unique_items</code> arguments were removed from <code>schema(...).field(...).had</code>. Notice that it's not a breaking change for most cases because passing these arguments caused exceptions</li> </ul>"},{"location":"home/CHANGELOG/#410","title":"[4.1.0]","text":""},{"location":"home/CHANGELOG/#added_10","title":"Added","text":"<ul> <li>Exposed <code>cadwyn.generate_versioned_models</code> that allow you to generate pydantic models and enums even without a FastAPI app</li> </ul>"},{"location":"home/CHANGELOG/#400","title":"[4.0.0]","text":"<p>Versions 3.x.x are still supported in terms of bug and security fixes but all the new features will go into versions 4.x.x.</p>"},{"location":"home/CHANGELOG/#added_11","title":"Added","text":"<ul> <li>Runtime schema/enum generation</li> <li>Support for versions as ISO date strings instead of dates in <code>cadwyn.migrate_response_body</code> and <code>cadwyn.Version</code></li> </ul>"},{"location":"home/CHANGELOG/#removed_3","title":"Removed","text":"<ul> <li>Pydantic 1 support</li> <li>Code generation from everywhere. It is now completely replaced by runtime generation (so schemas/enums are generated in the same manner as endpoints). This allows Cadwyn to version things outside of your project and allows you to pick any project structure unlike codegen that required a single \"head\" directory with all the versioned modules.</li> <li>CLI commands for codegen</li> <li><code>cadwyn.main</code> because it is replaced by <code>cadwyn.__init__</code></li> <li><code>cadwyn.structure.module</code> as it was only necessary in codegen</li> <li><code>cadwyn.VersionBundle.latest_schemas_package</code> and <code>cadwyn.VersionBundle.head_schemas_package</code>, <code>cadwyn.VersionBundle.versioned_modules</code>, <code>cadwyn.VersionBundle.versioned_directories_with_head</code>, <code>cadwyn.VersionBundle.versioned_directories_without_head</code>, because they were only necessary in code generation</li> <li><code>cadwyn.Cadwyn.add_unversioned_routers</code> as you can now simply use FastAPI's <code>include_router</code></li> <li><code>cadwyn.Cadwyn.add_unversioned_routes</code> as you can now simply use any of FastAPI's methods for adding routes directly to the app</li> <li><code>cadwyn.Cadwyn.enrich_swagger</code> as its functionality has been automated</li> <li><code>cadwyn.InternalRepresentationOf</code> as it was deprecated previously and is now replaced with HeadVersion migrations</li> </ul>"},{"location":"home/CHANGELOG/#changed_4","title":"Changed","text":"<ul> <li><code>VersionBundle.migrate_response_body</code> is no longer a method of <code>VersionBundle</code> and is now importable directly from <code>cadwyn</code> as a function</li> <li><code>cadwyn.structure</code> is no longer recommended to be used directly because everything from it is now available in <code>cadwyn</code> directly</li> </ul>"},{"location":"home/CHANGELOG/#3158","title":"[3.15.8]","text":""},{"location":"home/CHANGELOG/#fixed_21","title":"Fixed","text":"<ul> <li>Invalid unparseable JSON response without quotes when the response was a raw string JSONResponse</li> <li>An exception raised during codegen if a pydantic model or its parent were created within some indent such as classes defined under if statements</li> </ul>"},{"location":"home/CHANGELOG/#3157","title":"[3.15.7]","text":""},{"location":"home/CHANGELOG/#fixed_22","title":"Fixed","text":"<ul> <li>Wrong globals being used for wrapped endpoints in older versions, sometimes causing FastAPI to fail to resolve forward references on endpoint generation (see #192 for more details)</li> <li>dependency_overrides not working for old versions of the endpoints because they were wrapped and wraps did not have the same <code>__hash__</code> and <code>__eq__</code> as the original dependencies</li> </ul>"},{"location":"home/CHANGELOG/#3156","title":"[3.15.6]","text":""},{"location":"home/CHANGELOG/#added_12","title":"Added","text":"<ul> <li><code>HeadVersion</code> and <code>Version</code> into <code>cadwyn.__init__</code> so now they are directly importable from <code>cadwyn</code></li> </ul>"},{"location":"home/CHANGELOG/#fixed_23","title":"Fixed","text":"<ul> <li>Fix dependencies from other libraries not resolving if they use fastapi.Request or fastapi.Response (added svcs-specific test)</li> <li>Now a proper exception is used when no dated version was passed into <code>VersionBundle</code></li> </ul>"},{"location":"home/CHANGELOG/#3155","title":"[3.15.5]","text":""},{"location":"home/CHANGELOG/#fixed_24","title":"Fixed","text":"<ul> <li>Fix dependency overrides not working for versioned routes</li> </ul>"},{"location":"home/CHANGELOG/#3154","title":"[3.15.4]","text":""},{"location":"home/CHANGELOG/#changed_5","title":"Changed","text":"<ul> <li><code>Cadwyn.enrich_swagger</code> is now completely unnecessary: OpenAPI is now generated at runtime. It also now does not do anything, is deprecated, and will be removed in a future version</li> </ul>"},{"location":"home/CHANGELOG/#fixed_25","title":"Fixed","text":"<ul> <li>fastapi-pagination now does not require an explicit call to <code>Cadwyn.enrich_swagger</code></li> </ul>"},{"location":"home/CHANGELOG/#3153","title":"[3.15.3]","text":""},{"location":"home/CHANGELOG/#changed_6","title":"Changed","text":"<ul> <li><code>Cadwyn.router.routes</code> now includes all existing routers within the application instead of just unversioned routes</li> </ul>"},{"location":"home/CHANGELOG/#fixed_26","title":"Fixed","text":"<ul> <li>Compatibility with fastapi-pagination</li> <li>High cardinality of metrics for routers with path variables in starlette-exporter</li> </ul>"},{"location":"home/CHANGELOG/#3152","title":"[3.15.2]","text":""},{"location":"home/CHANGELOG/#fixed_27","title":"Fixed","text":"<ul> <li>OpenAPI not being generated when lifespan was used</li> </ul>"},{"location":"home/CHANGELOG/#3151","title":"[3.15.1]","text":""},{"location":"home/CHANGELOG/#fixed_28","title":"Fixed","text":"<ul> <li>Badge links in the readme</li> </ul>"},{"location":"home/CHANGELOG/#3150","title":"[3.15.0]","text":""},{"location":"home/CHANGELOG/#changed_7","title":"Changed","text":"<ul> <li>Optimized the calls to enrich_swagger which now happen on the startup event, once for the whole application</li> </ul>"},{"location":"home/CHANGELOG/#fixed_29","title":"Fixed","text":"<ul> <li>Oauth2 authentication parameters did not get passed to swagger</li> </ul>"},{"location":"home/CHANGELOG/#3140","title":"[3.14.0]","text":""},{"location":"home/CHANGELOG/#added_13","title":"Added","text":"<ul> <li>Current API version to per-version openapi.json</li> </ul>"},{"location":"home/CHANGELOG/#3130","title":"[3.13.0]","text":""},{"location":"home/CHANGELOG/#added_14","title":"Added","text":"<ul> <li>Validation for path converters to make sure that impossible HTTP methods cannot be used</li> <li>Validation for both path and schema converters to make sure that they are used at some point. Otherwise, router generation will raise an error</li> </ul>"},{"location":"home/CHANGELOG/#3121","title":"[3.12.1]","text":""},{"location":"home/CHANGELOG/#fixed_30","title":"Fixed","text":"<ul> <li><code>fastapi.Response</code> subclasses with non-null bodies and 500 response causing the response to not get returned</li> <li><code>fastapi.Response</code> subclasses had invalid content length if migration affected it</li> </ul>"},{"location":"home/CHANGELOG/#3120","title":"[3.12.0]","text":""},{"location":"home/CHANGELOG/#changed_8","title":"Changed","text":"<ul> <li>Rewritten header routing logic and structure to support the full feature set of FastAPI</li> </ul>"},{"location":"home/CHANGELOG/#3111","title":"[3.11.1]","text":""},{"location":"home/CHANGELOG/#fixed_31","title":"Fixed","text":"<ul> <li>Modules and enums from head versions not being detected and thus causing errors</li> </ul>"},{"location":"home/CHANGELOG/#3110","title":"[3.11.0]","text":""},{"location":"home/CHANGELOG/#changed_9","title":"Changed","text":"<ul> <li>Header router is no longer reliant on the API version header -- now it simply takes the API version from the <code>VersionBundle.api_version_var</code>, thus making it easy for someone to extend header routing and set their own rules for how the default version is chosen</li> </ul>"},{"location":"home/CHANGELOG/#3101","title":"[3.10.1]","text":""},{"location":"home/CHANGELOG/#fixed_32","title":"Fixed","text":"<ul> <li>Previous version introduced a minor breaking change: if any old users depended on the pure <code>generate_versioned_routers</code> interface, their work would receive a minor yet simple breaking change.</li> </ul>"},{"location":"home/CHANGELOG/#3100","title":"[3.10.0]","text":"<p>Yanked due to a minor breaking change that we fixed in 3.10.1.</p>"},{"location":"home/CHANGELOG/#added_15","title":"Added","text":"<ul> <li>The new approach to internal schemas: instead of having them duplicate certain fields from <code>latest</code>, we introduced a new <code>HEAD</code> version -- the only one the user maintains by hand. All requests get migrated to <code>HEAD</code> and latest schemas are generated from <code>HEAD</code>. <code>cadwyn.structure.HeadVersion</code> was added to give us the ability to have migrations between <code>HEAD</code> and latest, thus eliminating the need for <code>InternalRepresentationOf</code> because all the used schemas are now the internal representations</li> </ul>"},{"location":"home/CHANGELOG/#changed_10","title":"Changed","text":"<ul> <li><code>latest</code> is now named <code>head</code> because it no longer represents the newest version. Instead, it is the the <code>internally used</code> version and the version that is used for generating all other versions.</li> <li>the newest version is not aliased from <code>latest</code> anymore. Instead, it is generated like all the rest</li> <li>deprecated <code>InternalRepresentationOf</code> and the concept of <code>internal schemas</code> in favor of <code>HeadVersion</code> migrations</li> </ul>"},{"location":"home/CHANGELOG/#391","title":"[3.9.1]","text":""},{"location":"home/CHANGELOG/#fixed_33","title":"Fixed","text":"<ul> <li>A broken link to docs in README.md</li> </ul>"},{"location":"home/CHANGELOG/#390","title":"[3.9.0]","text":""},{"location":"home/CHANGELOG/#added_16","title":"Added","text":"<ul> <li>Support for getting openapi.json routes using API version headers instead of path query params</li> </ul>"},{"location":"home/CHANGELOG/#380","title":"[3.8.0]","text":""},{"location":"home/CHANGELOG/#added_17","title":"Added","text":"<ul> <li>Discord status badge in README</li> <li>Logos to existing status badges in README</li> <li>An ability to specify multiple schemas when using <code>convert_request_to_next_version_for</code> and <code>convert_response_to_next_version_for</code> to be able to migrate multiple types of schemas using the same converter</li> <li>Redoc support</li> </ul>"},{"location":"home/CHANGELOG/#removed_4","title":"Removed","text":"<ul> <li>Dependency from verselect. Now it is included as a part of Cadwyn</li> </ul>"},{"location":"home/CHANGELOG/#fixed_34","title":"Fixed","text":"<ul> <li><code>h11._util.LocalProtocolError</code> when raising <code>HTTPException(status_code=500)</code></li> </ul>"},{"location":"home/CHANGELOG/#371","title":"[3.7.1]","text":""},{"location":"home/CHANGELOG/#fixed_35","title":"Fixed","text":"<ul> <li>Error message for changing path params of an endpoint in an incompatible manner which listed methods instead of path params</li> </ul>"},{"location":"home/CHANGELOG/#changed_11","title":"Changed","text":"<ul> <li>Deprecated <code>cadwyn generate-code-for-versioned-packages</code> and added <code>cadwyn codegen</code> instead. It doesn't require <code>template_package</code> argument anymore and does not have the <code>ignore_coverage_for_latest_aliases</code> argument as we plan to remove this feature in the future. So it only requires <code>version_bundle</code>.</li> </ul>"},{"location":"home/CHANGELOG/#370","title":"[3.7.0]","text":""},{"location":"home/CHANGELOG/#changed_12","title":"Changed","text":"<ul> <li>Deprecated <code>cadwyn generate-code-for-versioned-packages</code> and added <code>cadwyn codegen</code> instead. It doesn't require <code>template_package</code> argument anymore and does not have the <code>ignore_coverage_for_latest_aliases</code> argument as we plan to remove this feature in the future. So it only requires <code>version_bundle</code>.</li> </ul>"},{"location":"home/CHANGELOG/#366","title":"[3.6.6]","text":""},{"location":"home/CHANGELOG/#fixed_36","title":"Fixed","text":"<ul> <li>When a class-based dependency from fastapi was used (anything security related), FastAPI had hardcoded <code>isinstance</code> checks for it which it used to enrich swagger with functionality. But when the dependencies were wrapped into our function wrappers, these checks stopped passing, thus breaking this functionality in swagger. Now we ignore all dependencies that FastAPI creates. This also introduces a hard-to-solve bug: if FastAPI's class-based security dependency was subclassed and then <code>__call__</code> was overridden with new dependencies that are versioned -- we will not migrate them from version to version. I hope this is an extremely rare use case though. In fact, such use case breaks Liskov Substitution Principle and doesn't make much sense because security classes already include <code>request</code> parameter which means that no extra dependencies or parameters are necessary.</li> </ul>"},{"location":"home/CHANGELOG/#365","title":"[3.6.5]","text":""},{"location":"home/CHANGELOG/#fixed_37","title":"Fixed","text":"<ul> <li>When a class-based dependency was used, its dependant was incorrectly generated, causing all affected endpoints to completely stop functioning</li> </ul>"},{"location":"home/CHANGELOG/#364","title":"[3.6.4]","text":""},{"location":"home/CHANGELOG/#363","title":"[3.6.3]","text":""},{"location":"home/CHANGELOG/#fixed_38","title":"Fixed","text":"<ul> <li>A rare pydantic 2 bug that caused <code>BaseModel</code> annotations to be corrupted when new fields were added to the schema</li> </ul>"},{"location":"home/CHANGELOG/#362","title":"[3.6.2]","text":""},{"location":"home/CHANGELOG/#fixed_39","title":"Fixed","text":"<ul> <li>Removed exception when creating <code>cadwyn.Cadwyn</code> without <code>latest_schemas_package</code> as it was a minor breaking change</li> </ul>"},{"location":"home/CHANGELOG/#360","title":"[3.6.0]","text":""},{"location":"home/CHANGELOG/#added_18","title":"Added","text":"<ul> <li>Add <code>cadwyn.VersionBundle.migrate_response_body</code> that allows us to migrate response bodies outside of routing and FastAPI</li> <li><code>latest_schemas_package</code> argument to <code>cadwyn.VersionBundle</code> to support the migration above</li> </ul>"},{"location":"home/CHANGELOG/#removed_5","title":"Removed","text":""},{"location":"home/CHANGELOG/#changed_13","title":"Changed","text":"<ul> <li>We now raise a 5xx error (<code>cadwyn.exceptions.CadwynLatestRequestValidationError</code>) whenever a request migration caused our payload to be incompatible with latest request schemas</li> <li>Deprecated <code>cadwyn.main</code> and use <code>cadwyn.applications</code> instead</li> <li>Deprecated <code>latest_schemas_package</code> argument in <code>cadwyn.Cadwyn</code></li> </ul>"},{"location":"home/CHANGELOG/#350","title":"[3.5.0]","text":""},{"location":"home/CHANGELOG/#fixed_40","title":"Fixed","text":"<ul> <li>Previously, Cadwyn did not set the default status code for ResponseInfo</li> </ul>"},{"location":"home/CHANGELOG/#added_19","title":"Added","text":"<ul> <li>HTTP status error handling in response converters using <code>convert_response_to_previous_version_for(...,  migrate_http_errors=True)</code></li> </ul>"},{"location":"home/CHANGELOG/#344","title":"[3.4.4]","text":""},{"location":"home/CHANGELOG/#fixed_41","title":"Fixed","text":"<ul> <li>Request and response converters were not applied when path params were present</li> </ul>"},{"location":"home/CHANGELOG/#343","title":"[3.4.3]","text":""},{"location":"home/CHANGELOG/#added_20","title":"Added","text":"<ul> <li><code>RouterPathParamsModifiedError</code> is now raised if <code>endpoint(...).had(path=...)</code> has different path params than the original route</li> </ul>"},{"location":"home/CHANGELOG/#342","title":"[3.4.2]","text":""},{"location":"home/CHANGELOG/#fixed_42","title":"Fixed","text":"<ul> <li>Fix import aliases in nested <code>__init__.py</code> files generating incorrectly for latest version</li> </ul>"},{"location":"home/CHANGELOG/#341","title":"[3.4.1]","text":""},{"location":"home/CHANGELOG/#fixed_43","title":"Fixed","text":"<ul> <li>If the endpoint specified a single non-pydantic (list/dict) body parameter, Cadwyn failed to serialize the body</li> </ul>"},{"location":"home/CHANGELOG/#340","title":"[3.4.0]","text":""},{"location":"home/CHANGELOG/#added_21","title":"Added","text":"<ul> <li><code>schema(...).validator(...).existed</code> and <code>schema(...).validator(...).didnt_exist</code> instructions for simplistic manipulation of validators</li> <li>Automatic deletion of validators when the fields they validate get deleted</li> <li><code>schema(...).field(...).didnt_have</code> for unsetting field attributes</li> <li>Improved support for <code>typing.Annotated</code> in schemas</li> <li>Full preservation of original abstract syntax trees for all field values and annotations</li> </ul>"},{"location":"home/CHANGELOG/#fixed_44","title":"Fixed","text":"<ul> <li>If the user wrote a wrong signature in a transformer decorated by <code>convert_request_to_next_version_for</code> or <code>convert_response_to_previous_version_for</code>, the text of the error suggested the wrong argument count and names</li> </ul>"},{"location":"home/CHANGELOG/#334","title":"[3.3.4]","text":""},{"location":"home/CHANGELOG/#fixed_45","title":"Fixed","text":"<ul> <li>Added backwards compatibility for FastAPI &lt; 0.106.0</li> </ul>"},{"location":"home/CHANGELOG/#333","title":"[3.3.3]","text":""},{"location":"home/CHANGELOG/#fixed_46","title":"Fixed","text":"<ul> <li>Guaranteed that it is impossible to release cadwyn with the wrong pydantic dependency</li> </ul>"},{"location":"home/CHANGELOG/#332","title":"[3.3.2]","text":""},{"location":"home/CHANGELOG/#fixed_47","title":"Fixed","text":"<ul> <li>Downgrade required version of verselect for backwards compatibility</li> </ul>"},{"location":"home/CHANGELOG/#331","title":"[3.3.1]","text":""},{"location":"home/CHANGELOG/#fixed_48","title":"Fixed","text":"<ul> <li>Removed lazy migrations as they were producing incorrect results when there were no migrations but when there were schema changes</li> <li>Added compatibility with fastapi&gt;=0.109.0</li> </ul>"},{"location":"home/CHANGELOG/#330","title":"[3.3.0]","text":""},{"location":"home/CHANGELOG/#fixed_49","title":"Fixed","text":"<ul> <li>If a user used a FastAPI/Starlette <code>StreamingResponse</code> or <code>FileResponse</code>, we still tried to access its <code>body</code> attribute which caused an <code>AttributeError</code></li> </ul>"},{"location":"home/CHANGELOG/#320","title":"[3.2.0]","text":""},{"location":"home/CHANGELOG/#added_22","title":"Added","text":"<ul> <li>Sponsors section to README and docs, along with Monite as our main and only current sponsor \u2728</li> </ul>"},{"location":"home/CHANGELOG/#313","title":"[3.1.3]","text":""},{"location":"home/CHANGELOG/#fixed_50","title":"Fixed","text":"<ul> <li>Switched to <code>better-ast-comments</code> because <code>ast-comments</code> had no license listed on pypi (even though its actual license was MIT) which caused some dependency checking tools to report it as unlicensed</li> </ul>"},{"location":"home/CHANGELOG/#312","title":"[3.1.2]","text":""},{"location":"home/CHANGELOG/#changed_14","title":"Changed","text":"<ul> <li>Migrate from black to ruff-format</li> </ul>"},{"location":"home/CHANGELOG/#fixed_51","title":"Fixed","text":"<ul> <li>A rare Pydantic 2 bug in internal body schema handling when it was applied too early, causing partially incomplete data to arrive to the handler</li> </ul>"},{"location":"home/CHANGELOG/#311","title":"[3.1.1]","text":""},{"location":"home/CHANGELOG/#fixed_52","title":"Fixed","text":"<ul> <li>Previously we did not pass <code>dependency_overrides_provider</code>, <code>response_model_exclude_unset</code> <code>response_model_exclude_defaults</code>, and <code>response_model_exclude_none</code> to <code>fastapi</code> which could cause erroneous behaviour during serialization in rare cases.</li> </ul>"},{"location":"home/CHANGELOG/#310","title":"[3.1.0]","text":""},{"location":"home/CHANGELOG/#added_23","title":"Added","text":"<ul> <li><code>module(...).had(import_=...)</code> construct for adding imports in older versions</li> <li>Codegen plugin system that allows easily customizing code generation for any purpose. It also significantly simplifies the core code of code generation</li> </ul>"},{"location":"home/CHANGELOG/#302","title":"[3.0.2]","text":""},{"location":"home/CHANGELOG/#fixed_53","title":"Fixed","text":"<ul> <li>If a user returned a FastAPI/Starlette <code>Response</code> with an empty body, we still tried to serialize it which caused an invalid response body</li> </ul>"},{"location":"home/CHANGELOG/#unreleased_1","title":"[Unreleased]","text":""},{"location":"home/CHANGELOG/#300","title":"[3.0.0]","text":""},{"location":"home/CHANGELOG/#added_24","title":"Added","text":"<ul> <li>Pydantic 2 support</li> <li>Expanded reference section to docs</li> <li>Contributor docs</li> <li>Expanded makefile commands</li> </ul>"},{"location":"home/CHANGELOG/#changed_15","title":"Changed","text":"<ul> <li>internal request representation is now done using an annotation</li> <li><code>latest_schemas_module</code> was renamed to <code>latest_schemas_package</code> everywhere</li> <li><code>api_version_var</code> in <code>VersionBundle</code> is now an optional argument instead of a required one</li> </ul>"},{"location":"home/CHANGELOG/#removed_6","title":"Removed","text":"<ul> <li><code>cadwyn.internal_body_representation_of</code> because it is now done using an annotation</li> </ul>"},{"location":"home/CHANGELOG/#234","title":"[2.3.4]","text":""},{"location":"home/CHANGELOG/#fixed_54","title":"Fixed","text":"<ul> <li><code>schema(...).field(...).had(ge=...)</code> for union fields previously raised an <code>AttributeError</code> on code generation</li> </ul>"},{"location":"home/CHANGELOG/#233","title":"[2.3.3]","text":""},{"location":"home/CHANGELOG/#fixed_55","title":"Fixed","text":"<ul> <li>Field ASTs not preserving the original structure when constrained fields were changed</li> </ul>"},{"location":"home/CHANGELOG/#added_25","title":"Added","text":"<ul> <li>Support for synchronous endpoints</li> </ul>"},{"location":"home/CHANGELOG/#232","title":"[2.3.2]","text":""},{"location":"home/CHANGELOG/#fixed_56","title":"Fixed","text":"<ul> <li>The bug where fields from parent schemas also appeared in child schemas</li> </ul>"},{"location":"home/CHANGELOG/#231","title":"[2.3.1]","text":""},{"location":"home/CHANGELOG/#changed_16","title":"Changed","text":"<ul> <li>Migrate from external verselect to stable verselect</li> </ul>"},{"location":"home/CHANGELOG/#230","title":"[2.3.0]","text":""},{"location":"home/CHANGELOG/#fixed_57","title":"Fixed","text":"<ul> <li>Previously whenever we generated routes, we wrapped all endpoints and callbacks in decorators for every version which caused stacktraces to be unnecessarily huge. Now there is only one wrapper for all versions</li> </ul>"},{"location":"home/CHANGELOG/#added_26","title":"Added","text":"<ul> <li><code>cadwyn.Cadwyn</code> class similar to <code>fastapi.FastAPI</code> that provides header routing and encapsulates all information about versioned routes</li> <li>Migrated from <code>fastapi-header-routing</code> to <code>verselect</code></li> <li><code>cadwyn.routing.VERSION_HEADER_FORMAT</code> from <code>verselect.routing</code></li> </ul>"},{"location":"home/CHANGELOG/#changed_17","title":"Changed","text":"<ul> <li><code>*versions</code> argument in <code>cadwyn.VersionBundle</code> is now split into a required positional-only <code>latest_version</code> and <code>*other_versions</code> to make it possible to see an invalid versionless definition statically. Note that it is not a breaking change because the presence of at least one version was also implicitly required before and would produce a failure at runtime</li> </ul>"},{"location":"home/CHANGELOG/#removed_7","title":"Removed","text":"<ul> <li><code>cadwyn.get_cadwyn_dependency</code> and <code>cadwyn.header</code> because it is fully replaced with <code>verselect</code></li> </ul>"},{"location":"home/CHANGELOG/#220","title":"[2.2.0]","text":""},{"location":"home/CHANGELOG/#added_27","title":"Added","text":"<ul> <li>Validation for the spelling of HTTP methods in <code>cadwyn.structure.endpoint</code>.</li> </ul>"},{"location":"home/CHANGELOG/#210","title":"[2.1.0]","text":""},{"location":"home/CHANGELOG/#added_28","title":"Added","text":"<ul> <li>A prototype of AST-based code generation where we try to keep as much of the old field/annotation structure as possible</li> </ul>"},{"location":"home/CHANGELOG/#205","title":"[2.0.5]","text":""},{"location":"home/CHANGELOG/#fixed_58","title":"Fixed","text":"<ul> <li><code>UploadFile</code> and forms have previously caused exceptions on request migration</li> </ul>"},{"location":"home/CHANGELOG/#204","title":"[2.0.4]","text":""},{"location":"home/CHANGELOG/#fixed_59","title":"Fixed","text":"<ul> <li><code>ContextVar[datetime.date]</code> being incompatible with <code>VersionBundle</code></li> </ul>"},{"location":"home/CHANGELOG/#203","title":"[2.0.3]","text":""},{"location":"home/CHANGELOG/#added_29","title":"Added","text":"<ul> <li>A note into reference docs about the paths specification in CLI</li> </ul>"},{"location":"home/CHANGELOG/#fixed_60","title":"Fixed","text":"<ul> <li>Custom body fields created by FastAPI caused an exception. Now they are ignored</li> </ul>"},{"location":"home/CHANGELOG/#202","title":"[2.0.2]","text":""},{"location":"home/CHANGELOG/#added_30","title":"Added","text":"<ul> <li>A link to OpenAPI discussion on enum expansion into docs/recipes</li> <li>A link to intercom's API versioning article into docs/theory</li> </ul>"},{"location":"home/CHANGELOG/#201","title":"[2.0.1]","text":""},{"location":"home/CHANGELOG/#fixed_61","title":"Fixed","text":"<ul> <li><code>generate_versioned_routers</code> did not alter <code>APIRoute.dependant.call</code>, <code>APIRoute.response_field</code>, and <code>APIRoute.secure_cloned_response_field</code> before which caused these fields to represent latest version on all generated versions. However, this was only a bug if the routes were later added into the app/router by hand instead of using <code>inherit_routes</code> or <code>add_api_route</code>.</li> </ul>"},{"location":"home/CHANGELOG/#200","title":"[2.0.0]","text":""},{"location":"home/CHANGELOG/#changed_18","title":"Changed","text":"<ul> <li><code>generate_versioned_routers</code> now accepts only one router instead of a sequence of routers to give us the ability to guarantee that the type of generated routers is the same as the type of the passed router.</li> </ul>"},{"location":"home/CHANGELOG/#140","title":"[1.4.0]","text":""},{"location":"home/CHANGELOG/#added_31","title":"Added","text":"<ul> <li>Theory section to docs</li> </ul>"},{"location":"home/CHANGELOG/#130","title":"[1.3.0]","text":""},{"location":"home/CHANGELOG/#added_32","title":"Added","text":"<ul> <li>Recipes documentation section</li> <li><code>schema(...).field(...).had(name=...)</code> functionality to rename fields</li> </ul>"},{"location":"home/CHANGELOG/#changed_19","title":"Changed","text":"<ul> <li>Tutorial example structure in tests</li> </ul>"},{"location":"home/CHANGELOG/#120-2023-10-16","title":"[1.2.0] - 2023-10-16","text":""},{"location":"home/CHANGELOG/#added_33","title":"Added","text":"<ul> <li><code>cadwyn.main._Cadwyn</code> experimental private class for automatically adding the header dependency and managing all objects related to versioning</li> </ul>"},{"location":"home/CHANGELOG/#removed_8","title":"Removed","text":"<ul> <li><code>cadwyn.header_routing</code> which only had experimental private functions</li> </ul>"},{"location":"home/CHANGELOG/#fixed_62","title":"Fixed","text":"<ul> <li>Route callbacks didn't get migrated to versions with their parent routes</li> </ul>"},{"location":"home/CHANGELOG/#110-2023-10-13","title":"[1.1.0] - 2023-10-13","text":""},{"location":"home/CHANGELOG/#added_34","title":"Added","text":"<ul> <li><code>ignore_coverage_for_latest_aliases</code> argument to <code>generate_code_for_versioned_packages</code> which controls whether we add \"a pragma: no cover\" comment to the star imports in the generated version of the latest module. It is True by default.</li> </ul>"},{"location":"home/CHANGELOG/#103-2023-10-10","title":"[1.0.3] - 2023-10-10","text":""},{"location":"home/CHANGELOG/#fixed_63","title":"Fixed","text":"<ul> <li>Add back the approach where the first version being an alias to latest in codegen</li> </ul>"},{"location":"home/CHANGELOG/#102-2023-10-09","title":"[1.0.2] - 2023-10-09","text":""},{"location":"home/CHANGELOG/#fixed_64","title":"Fixed","text":"<ul> <li>Add current working dir to <code>sys.path</code> when running code generation through CLI</li> <li>Use <code>exclude_unset</code> when migrating the body of a request to make sure that users' <code>exclude_unset</code> logic gets preserved</li> </ul>"},{"location":"home/CHANGELOG/#101-2023-10-09","title":"[1.0.1] - 2023-10-09","text":""},{"location":"home/CHANGELOG/#fixed_65","title":"Fixed","text":"<ul> <li>Pass first argument in <code>typer.Argument</code> to prevent errors on older typer versions</li> </ul>"},{"location":"home/CHANGELOG/#100-2023-10-09","title":"[1.0.0] - 2023-10-09","text":""},{"location":"home/CHANGELOG/#added_35","title":"Added","text":"<ul> <li>Command-line interface capable of running code-generation and outputting version info</li> <li>Internal request schema which gives us all the functionality we could ever need to migrate request bodies forward without any complexity of the prior solution</li> <li><code>_get_versioned_router</code> and experimental header routing with it (by @tikon93). Note that the interface for this feature will change in the future</li> </ul>"},{"location":"home/CHANGELOG/#changed_20","title":"Changed","text":"<ul> <li>Renamed <code>cadwyn.regenerate_dir_to_all_versions</code> to <code>cadwyn.generate_code_for_versioned_packages</code></li> <li>Renamed <code>cadwyn.generate_all_router_versions</code> to <code>cadwyn.generate_versioned_routers</code></li> </ul>"},{"location":"home/CHANGELOG/#removed_9","title":"Removed","text":"<ul> <li><code>unions</code> directory and all logic around it (replaced by internal request schema)</li> <li><code>FillablePrivateAttr</code> and all logic around it (replaced by internal request schema)</li> <li><code>schema(...).property</code> constructor and all logic around it (replaced by internal request schema)</li> <li>Special-casing for code generation of package with latest version using star imports from latest (replaced by internal request schema)</li> </ul>"},{"location":"home/CONTRIBUTING/","title":"Contribution Guide","text":""},{"location":"home/CONTRIBUTING/#setting-up-the-environment","title":"Setting up the environment","text":"<ul> <li>The lowest currently supported version is Python 3.10. You should use uv to manage multiple Python versions on your system.</li> <li> <p>We maintain a Makefile with several commands to help with common tasks.</p> </li> <li> <p>Install uv</p> </li> <li>Run <code>uv sync</code> to create a virtual environment and install the required development dependencies</li> <li>Install pre-commit using uv: <code>uv tool install pre-commit</code></li> <li>Run <code>pre-commit install --install-hooks</code> to install pre-commit hooks</li> </ul>"},{"location":"home/CONTRIBUTING/#code-contributions","title":"Code contributions","text":""},{"location":"home/CONTRIBUTING/#workflow","title":"Workflow","text":"<ol> <li>Fork the Cadwyn repository</li> <li>Clone your fork locally with git</li> <li>Set up the environment</li> <li>Make your changes</li> <li>Commit your changes to git.</li> <li>Open a pull request. Give the pull request a descriptive title indicating what it changes.</li> </ol>"},{"location":"home/CONTRIBUTING/#guidelines-for-writing-code","title":"Guidelines for writing code","text":"<ul> <li>Code should be Pythonic and zen</li> <li>All code should be fully typed. This is enforced via ruff but the type hinting itself will be enforced by pyright in the future.</li> <li>When requiring complex types, use a type alias.</li> <li>If something cannot be typed correctly due to a limitation of the type checkers, you may use typing.cast to rectify the situation. However, you should only use as a last resort if you've exhausted all other options of type narrowing, such as isinstance() checks and type guards</li> <li>You may use <code>pyright: ignore</code> if you ensured that a line is correct, but pyright has issues with it.</li> <li>If you are adding or modifying existing code, ensure that it's fully tested. 100% test coverage is mandatory, and will be checked on the PR using Github Actions</li> <li>When adding a new public interface, it has to be included in the concept documentation located in <code>docs/concepts.md</code>. If applicable, add or modify examples in the docs related to the new functionality implemented.</li> </ul>"},{"location":"home/CONTRIBUTING/#writing-and-running-tests","title":"Writing and running tests","text":"<p>Tests are contained within the <code>tests</code> directory, and follow roughly the same directory structure as the <code>cadwyn</code> module. If you are adding a test case, it should be located within the correct submodule of <code>tests</code>. E.g. tests for <code>cadwyn/codegen.py</code> reside in <code>tests/codegen</code>.</p> <p><code>make test</code> to run tests located in <code>tests</code></p>"},{"location":"home/CONTRIBUTING/#running-type-checkers","title":"Running type checkers","text":"<p>We use pyright to enforce type safety. You can run it with:</p> <p><code>uv run pyright .</code></p>"},{"location":"home/CONTRIBUTING/#project-documentation","title":"Project documentation","text":"<p>The documentation is located in the <code>/docs</code> directory and is all in Markdown.</p>"},{"location":"home/CONTRIBUTING/#docs-theme-and-appearance","title":"Docs theme and appearance","text":"<p>We welcome contributions that enhance / improve the appearance and usability of the docs. We use mkdocs-material If you wish to contribute to the docs style / setup, or static site generation, you should consult the theme docs as a first step.</p>"},{"location":"home/CONTRIBUTING/#running-the-docs-locally","title":"Running the docs locally","text":"<p>Then you can serve the documentation with <code>mkdocs serve</code></p>"},{"location":"home/CONTRIBUTING/#writing-and-editing-docs","title":"Writing and editing docs","text":"<p>We welcome contributions that enhance / improve the content of the docs. Feel free to add examples, clarify text, restructure the docs, etc., but make sure to follow these guidelines:</p> <ul> <li>Write text in idiomatic English, using simple language</li> <li>Opt for Oxford commas when listing a series of terms</li> <li>Keep examples simple and self contained</li> <li>Provide links where applicable</li> </ul>"},{"location":"how_to/","title":"How to...","text":"<p>This section serves as a guide to help you create new versions effectively and maintain your old versions with ease. It consists of a collection of scenarios for different types of breaking changes.</p> <p>To follow this guide, choose a type of an entity that you'd like to alter (an endpoint, a schema, etc), find the respective article, and follow its instructions. Repeat for every breaking change you would like to do.</p> <p>Versioning is a complex topic with more pitfalls than you'd expect so please: do not try to skip this guide. Otherwise, your code will quickly get unmaintainable. Please also note that any of these scenarios can be combined in any way even within a single version change, though it's recommended to keep the version changes atomic as described in methodology section.</p>"},{"location":"how_to/version_with_paths_and_numbers_instead_of_headers_and_dates/","title":"Version with paths and numbers instead of headers and dates","text":"<p>Cadwyn uses version headers with ISO dates by default for versioning. However, you can use any strings instead of ISO dates and/or you can use path version prefixes instead of version headers. Here's our quickstart tutorial example but using version numbers and path prefixes:</p> <p>Feel free to mix and match the API version formats and version locations as you see fit. But beware that Cadwyn does not support version waterfalling for arbitrary strings as versions.</p> <pre><code>import uuid\n\nfrom cadwyn import VersionedAPIRouter\nfrom cadwyn.applications import Cadwyn\nfrom cadwyn.structure import (\n    RequestInfo,\n    ResponseInfo,\n    Version,\n    VersionBundle,\n    VersionChange,\n    convert_request_to_next_version_for,\n    convert_response_to_previous_version_for,\n    endpoint,\n    schema,\n)\nfrom cadwyn.structure.versions import HeadVersion\nfrom pydantic import BaseModel, Field\n\n\nclass BaseUser(BaseModel):\n    pass\n\n\nclass UserCreateRequest(BaseUser):\n    default_address: str\n    addresses_to_create: list[str] = Field(default_factory=list)\n\n\nclass UserResource(BaseUser):\n    id: uuid.UUID\n\n\nclass UserAddressResource(BaseModel):\n    id: uuid.UUID\n    value: str\n\n\nclass UserAddressResourceList(BaseModel):\n    data: list[UserAddressResource]\n\n\nclass ChangeAddressToList(VersionChange):\n    description = \"Change vat id to list\"\n    instructions_to_migrate_to_previous_version = (\n        schema(BaseUser).field(\"addresses\").didnt_exist,\n        schema(BaseUser).field(\"address\").existed_as(type=str, info=Field()),\n    )\n\n    @convert_request_to_next_version_for(UserCreateRequest)\n    def change_address_to_multiple_items(request: RequestInfo) -&gt; None:\n        request.body[\"addresses\"] = [request.body.pop(\"address\")]\n\n    @convert_response_to_previous_version_for(UserResource)\n    def change_addresses_to_single_item(response: ResponseInfo) -&gt; None:\n        # Need to assert addresses length somewhere in business logic\n        response.body[\"address\"] = response.body[\"addresses\"][0]\n\n\nclass ChangeAddressesToSubresource(VersionChange):\n    description = \"Change vat ids to subresource\"\n    instructions_to_migrate_to_previous_version = (\n        schema(BaseUser)\n        .field(\"addresses\")\n        .existed_as(type=list[str], info=Field()),\n        schema(UserCreateRequest).field(\"default_address\").didnt_exist,\n        endpoint(\n            \"/{api_version}/users/{user_id}/addresses\", [\"GET\"]\n        ).didnt_exist,\n    )\n\n    @convert_request_to_next_version_for(UserCreateRequest)\n    def change_addresses_to_default_address(request: RequestInfo):\n        request.body[\"default_address\"] = request.body[\"addresses\"].pop(0)\n        # Save data to still be able to keep the old behavior of creating addresses\n        request.body[\"addresses_to_create\"] = request.body.pop(\"addresses\")\n\n    @convert_response_to_previous_version_for(UserResource)\n    def change_addresses_to_list(response: ResponseInfo) -&gt; None:\n        response.body[\"addresses\"] = [\n            id[\"value\"] for id in response.body[\"_prefetched_addresses\"]\n        ]\n\n\nclass RemoveAddressesToCreateFromLatest(VersionChange):\n    description = (\n        \"In order to support old versions, we gotta have `addresses_to_create` \"\n        \"located in head schemas but we do not need this field in latest schemas.\"\n    )\n    instructions_to_migrate_to_previous_version = (\n        schema(UserCreateRequest).field(\"addresses_to_create\").didnt_exist,\n    )\n\n\nversion_bundle = VersionBundle(\n    HeadVersion(RemoveAddressesToCreateFromLatest),\n    Version(\"v10\", ChangeAddressesToSubresource),\n    Version(\"v9\", ChangeAddressToList),\n    Version(\"v8\"),\n)\n\n\nrouter = VersionedAPIRouter(tags=[\"Users\"])\ndatabase_parody = {}\n\n\n@router.post(\"/{api_version}/users\", response_model=UserResource)\nasync def create_user(user: UserCreateRequest):\n    id_ = uuid.uuid4()\n    database_parody[id_] = {\"id\": id_}\n    addresses = create_user_addresses(\n        id_, [user.default_address, *user.addresses_to_create]\n    )\n    return database_parody[id_] | {\"_prefetched_addresses\": addresses}\n\n\n@router.get(\"/{api_version}/users/{user_id}\", response_model=UserResource)\nasync def get_user(user_id: uuid.UUID):\n    return {\n        \"id\": user_id,\n        \"_prefetched_addresses\": (await get_user_addresses(user_id))[\"data\"],\n    }\n\n\ndef create_user_addresses(user_id: uuid.UUID, addresses: list[str]):\n    database_parody[f\"addr_{user_id}\"] = [\n        {\"id\": uuid.uuid4(), \"value\": address} for address in addresses\n    ]\n    return database_parody[f\"addr_{user_id}\"]\n\n\n@router.get(\n    \"/{api_version}/users/{user_id}/addresses\",\n    response_model=UserAddressResourceList,\n)\nasync def get_user_addresses(user_id: uuid.UUID):\n    return {\"data\": database_parody[f\"addr_{user_id}\"]}\n\n\napp = Cadwyn(\n    versions=version_bundle,\n    api_version_parameter_name=\"api_version\",\n    api_version_format=\"string\",\n    api_version_location=\"path\",\n)\napp.generate_and_include_versioned_routers(router)\n</code></pre>"},{"location":"how_to/change_business_logic/","title":"Change the business logic in a new version","text":"<p>First, ask yourself: are you sure there really needs to be a behavioral change? Are you sure it is not possible to keep the same logic for both versions? Or at least make the behavior depend on the received data? Behavioral changes (or side effects) are the least maintainable part of almost any versioning approach. They produce the largest footprint on your code so if you are not careful -- your logic will be littered with version checks.</p> <p>But if you are certain that you need to make a breaking behavioral change, Cadwyn has all the tools to minimize its impact as much as possible.</p>"},{"location":"how_to/change_business_logic/#calling-endpoint-causes-unexpected-data-modifications","title":"Calling endpoint causes unexpected data modifications","text":"<p>You'd use an <code>if statement</code> with a side effect.</p>"},{"location":"how_to/change_business_logic/#calling-endpoint-doesnt-cause-expected-data-modifications","title":"Calling endpoint doesn't cause expected data modifications","text":"<p>You'd use an <code>if statement</code> with a side effect.</p>"},{"location":"how_to/change_business_logic/#calling-endpoint-doesnt-cause-expected-additional-actions-eg-webhooks","title":"Calling endpoint doesn't cause expected additional actions (e.g. Webhooks)","text":"<p>You'd use an <code>if statement</code> with a side effect.</p>"},{"location":"how_to/change_business_logic/#errors","title":"Errors","text":""},{"location":"how_to/change_business_logic/#change-the-status-code-or-a-message-in-an-http-error","title":"Change the status code or a message in an HTTP error","text":"<p>You can migrate anything about the error in a version change.</p>"},{"location":"how_to/change_business_logic/#introduce-a-new-error-or-remove-an-old-error","title":"Introduce a new error or remove an old error","text":"<p>You'd use an <code>if statement</code> with a side effect.</p>"},{"location":"how_to/change_endpoints/","title":"Change endpoints in a new version","text":""},{"location":"how_to/change_endpoints/#add-a-new-endpoint","title":"Add a new endpoint","text":"<p>It is not a breaking change so it's recommended to simply add it to all versions. If you believe that you still need it, you can use the following migration.</p>"},{"location":"how_to/change_endpoints/#delete-an-old-endpoint","title":"Delete an old endpoint","text":"<p>See concepts</p>"},{"location":"how_to/change_endpoints/#change-an-attribute-of-an-endpoint","title":"Change an attribute of an endpoint","text":"<p>Changing a \"decoratory\" attribute such as description or summary is generally not a breaking change and should just be applied to all versions.</p> <p>However, you are still free to change almost any attribute of an endpoint in the old version. See concepts docs.</p>"},{"location":"how_to/change_endpoints/#rename-an-endpoint","title":"Rename an endpoint","text":"<p>Renaming endpoints is the same as changing their \"path\" attribute. See concepts docs for more details.</p>"},{"location":"how_to/change_openapi_schemas/add_field/","title":"Add a field to OpenAPI schemas","text":""},{"location":"how_to/change_openapi_schemas/add_field/#to-response-schema","title":"To response schema","text":"<p>Let's say that we decided to expose the creation date of user's account with a <code>created_at</code> field in our API. This is not a breaking change so a new version is completely unnecessary. However, if you believe that you absolutely have to make a new version, then you can simply follow the recommended approach below but add a version change with field didn't exist instruction.</p> <p>You just need to add <code>created_at</code> field into <code>users.UserResource</code>.</p> <p>Now you have everything you need at your disposal: field <code>created_at</code> is available in all versions and your users do not even need to do any extra actions. Just make sure that the data for it is available in all versions too. If it's not: make the field optional.</p>"},{"location":"how_to/change_openapi_schemas/add_field/#to-both-request-and-response-schemas","title":"To both request and response schemas","text":""},{"location":"how_to/change_openapi_schemas/add_field/#field-is-optional","title":"Field is optional","text":"<p>Let's say we want our users to be able to specify a middle name but it is nullable. It is not a breaking change so no new version is necessary whether it is requests or responses.</p> <p>You just need to add a nullable <code>middle_name</code> field into <code>users.BaseUser</code> as if you were working with a barebones FastAPI app.</p>"},{"location":"how_to/change_openapi_schemas/add_field/#field-is-required","title":"Field is required","text":""},{"location":"how_to/change_openapi_schemas/add_field/#with-compatible-default-value-in-older-versions","title":"With compatible default value in older versions","text":"<p>Let's say that our users had a field <code>country</code> that defaulted to <code>USA</code> but our product is now used well beyond United States so we want to make this field required in the HEAD version.</p> <ol> <li>Remove <code>default=\"US\"</code> from <code>users.UserCreateRequest</code></li> <li> <p>Add the following migration to <code>versions.v2001_01_01</code>:</p> <pre><code>from cadwyn import (\n    VersionChange,\n    schema,\n    convert_request_to_next_version_for,\n)\nfrom users import UserCreateRequest, UserResource\n\n\nclass MakeUserCountryRequired(VersionChange):\n    description = 'Make user country required instead of the \"USA\" default'\n    instructions_to_migrate_to_previous_version = (\n        schema(UserCreateRequest).field(\"country\").had(default=\"USA\"),\n    )\n\n    @convert_request_to_next_version_for(UserCreateRequest)\n    def add_default_value_to_country_field_in_request(request: RequestInfo):\n        request.body[\"country\"] = request.body.get(\"country\", \"USA\")\n</code></pre> </li> <li> <p>Add this migration into the version bundle:</p> <pre><code>from cadwyn import Version, VersionBundle, HeadVersion\nfrom datetime import date\nfrom .v2001_01_01 import MakeUserCountryRequired\n\nversion_bundle = VersionBundle(\n    HeadVersion(),\n    Version(\"2001-01-01\", MakeUserCountryRequired),\n    Version(\"2000-01-01\"),\n)\n</code></pre> </li> </ol> <p>That's it! Our old schemas will now contain a default but in HEAD country will be required. You might notice a weirdness: if we set a default in the old version, why would we also write a migration? That's because of a sad implementation detail of pydantic that prevents us from using defaults from old versions.</p>"},{"location":"how_to/change_openapi_schemas/add_field/#with-incompatible-default-value-in-older-versions","title":"With incompatible default value in older versions","text":"<p>Let's say that we want to add a required field <code>phone</code> to our users. However, older versions did not have such a field at all. This means that the field is going to be nullable (or nonexistent) in the old versions but required in the HEAD version. This also means that older versions contain a wider type (<code>str | None</code>) than the HEAD version (<code>str</code>). So when we try to migrate request bodies from the older versions to HEAD -- we might receive a <code>ValidationError</code> because <code>None</code> is not an acceptable value for <code>phone</code> field in the new version. Whenever we have a problem like this, when older version contains more data or a wider type set of data,  we can simply define a wider type in our HEAD version and then narrow it in latest.</p> <p>So we will make <code>phone</code> nullable in HEAD, then make it required in <code>latest</code>, and then make it nullable again in older versions, thus making it possible to convert all of our requests to HEAD.</p> <ol> <li>Add <code>phone</code> field of type <code>str | None</code> to <code>users.BaseUser</code></li> <li>Add <code>phone</code> field of type <code>str | None</code> with a <code>default=None</code> to <code>users.UserResource</code> because all users created with older versions of our API won't have phone numbers.</li> <li> <p>Add the following migration to <code>versions.v2001_01_01</code> which will make sure that <code>phone</code> is not nullable in 2001_01_01:</p> <pre><code>from cadwyn import VersionChange, schema\nfrom users import UserCreateRequest\n\n\nclass MakePhoneNonNullableInLatest(VersionChange):\n    description = (\n        \"Make sure the phone is nullable in the HEAD version to support \"\n        \"versions older than 2001_01_01 where it became non-nullable\"\n    )\n    instructions_to_migrate_to_previous_version = (\n        schema(UserCreateRequest).field(\"phone\").had(type=str),\n        schema(UserCreateRequest).field(\"phone\").didnt_have(\"default\"),\n    )\n</code></pre> </li> <li> <p>Add the following version change to <code>versions.v2001_01_01</code> (right under the version change above) which will make sure that <code>phone</code> is nullable in 2000_01_01:</p> <pre><code>class AddPhoneToUser(VersionChange):\n    description = (\n        \"Add a required phone field to User to allow us to do 2fa and to \"\n        \"make it possible to verify new user accounts using an sms.\"\n    )\n    instructions_to_migrate_to_previous_version = (\n        schema(UserCreateRequest)\n        .field(\"phone\")\n        .had(type=str | None, default=None),\n    )\n</code></pre> </li> <li> <p>Add both migrations into our VersionBundle:</p> <pre><code>from cadwyn import Version, VersionBundle, HeadVersion\nfrom datetime import date\nfrom .v2001_01_01 import MakePhoneNonNullableInLatest, AddPhoneToUser\n\n\nversion_bundle = VersionBundle(\n    HeadVersion(MakePhoneNonNullableInLatest),\n    Version(\"2001-01-01\", AddPhoneToUser),\n    Version(\"2000-01-01\"),\n)\n</code></pre> </li> </ol> <p>See how we didn't remove the <code>phone</code> field from old versions? Instead, we allowed a nullable <code>phone</code> field to be passed into both old <code>UserResource</code> and old <code>UserCreateRequest</code>. This gives our users new functionality without needing to update their API version! It is one of the best parts of Cadwyn's approach: our users can get years worth of updates without switching their API version and without their integration getting broken.</p>"},{"location":"how_to/change_openapi_schemas/change_field_type/","title":"Change field type in schemas","text":""},{"location":"how_to/change_openapi_schemas/change_field_type/#incompatibly-change-the-type","title":"Incompatibly change the type","text":"<p>If your data had a type <code>int</code> and you want to change it to an <code>str</code> in a new version, then your data from the new version can easily break the responses of the old versions, thus making it data versioning, not API versioning -- as you are versioning the fundamental structures the user is operating on instead of just the API.</p>"},{"location":"how_to/change_openapi_schemas/change_field_type/#expand-the-type","title":"Expand the type","text":"<p>Let's say that our clients could choose a <code>role</code> for our users. Originally, it was only possible to choose <code>admin</code> or <code>regular</code> but we would like to expand it to <code>moderator</code> which has all the powers of an admin except that moderators cannot assign other admins.</p> <p>This is not a breaking change in terms of requests but it can be a breaking change in terms of responses.</p> <p>So if you do consider it a breaking change in terms of responses, you should do the following:</p> <ol> <li>Add <code>moderator</code> value into <code>users.BaseUserRoleEnum</code></li> <li> <p>Add the following migration to <code>versions.v2001_01_01</code>:</p> <pre><code>from cadwyn import (\n    VersionChange,\n    enum,\n    convert_response_to_previous_version_for,\n    ResponseInfo,\n)\nfrom users import UserRoleEnum, UserResource\nimport datetime\n\n\nclass AddModeratorRoleToUser(VersionChange):\n    description = (\n        \"Add 'moderator' role to users that represents an admin that \"\n        \"cannot create or remove other admins. This allows for a \"\n        \"finer-grained permission control.\"\n    )\n    instructions_to_migrate_to_previous_version = (\n        enum(UserRoleEnum).didnt_have(\"moderator\"),\n    )\n\n    @convert_response_to_previous_version_for(UserResource)\n    def change_moderator_to_regular(response: ResponseInfo):\n        if response.body[\"role\"] == \"moderator\":\n            response.body[\"role\"] = \"regular\"\n</code></pre> </li> </ol> <p>We convert moderators to regulars in older versions because it is a safer choice for our users.</p>"},{"location":"how_to/change_openapi_schemas/change_field_type/#why-enum-expansion-is-a-breaking-change-for-responses","title":"Why enum expansion is a breaking change for responses","text":"<p>Let's that our schema includes a list that contains euros and/or dollars. Using our framework for unmarshalling JSON, we take the JSON string and try to convert it into the list of euros and/or dollars. If we suddenly see Georgian lari there -- our unmarshalling framework freaks out because the list is not what it expected, which makes adding an enum value a breaking change when you have a list of items.</p> <p>To be more precise: If I, as a client, expect <code>Array&lt;Euro | Dollar&gt;</code>, then <code>Array&lt;Euro&gt;</code> would be a compatible response and <code>Array&lt;Dollar&gt;</code> would be a compatible response BUT <code>Array&lt;Euro | Dollar | Lari&gt;</code> would be an incompatible response. That is the case because <code>Array&lt;Euro | Dollar | Lari&gt;</code> is a not a subtype of <code>Array&lt;Euro | Dollar&gt;</code> while <code>Array&lt;Euro&gt;</code> is.</p> <p>In a sense, extending an enum that has <code>USD</code> with <code>USD | EUR</code> is equivalent to turning an <code>int</code> field into an <code>int | str</code> field, which is a breaking change. Hence extending an enum is often a breaking change and thus we might not need to solve this problem at all.</p> <p>Additional resources:</p> <ul> <li>https://github.com/OAI/OpenAPI-Specification/issues/1552</li> <li>https://users.rust-lang.org/t/solved-is-adding-an-enum-variant-a-breaking-change/26721/5</li> <li>https://github.com/graphql/graphql-js/issues/968</li> </ul> <p>In these sections, we'll be working with our user's response model: <code>users.UserResource</code>. Note that the main theme here is \"Will I be able to serialize this change to any of my versions?\" as any change to responses can make them incompatible with the data in your database.</p>"},{"location":"how_to/change_openapi_schemas/change_field_type/#narrow-the-type","title":"Narrow the type","text":"<p>Let's say that previously users could specify their date of birth as a datetime instead of a date. We wish to rectify that. We can solve this by making it a datetime in HEAD version, converting it to date in latest version, and then making it a datetime again in the old versions. So whenever we receive a request in an old version, it will get converted to HEAD version where it is a datetime. And whenever we receive a request in latest version, it will also be converted to HEAD where date will simply be casted to datetime with time = 00:00:00.</p> <ol> <li>Continue storing <code>date_of_birth</code> as a datetime in your database to avoid breaking any old behavior</li> <li> <p>Add the following migration to <code>versions.v2001_01_01</code> which will turn <code>date_of_birth</code> into a date in 2001_01_01. Note how we use the validator for making sure that <code>date_of_birth</code> is converted to date in the latest version. It is only necessary in Pydantic 2 because it has no implicit casting from datetime to date. Note also how we use strings for types: this is not always necessary; it just allows you to control specifically how Cadwyn is going to render your types. Most of the time you won't need to use strings for types.</p> <pre><code>from cadwyn import VersionChange, schema\nfrom pydantic import validator\nfrom users import BaseUser\nimport datetime\n\n\n@field_validator(\"date_of_birth\", mode=\"before\")\ndef convert_date_of_birth_to_date(cls, v: datetime.date | datetime.datetime):\n    if isinstance(v, datetime.datetime):\n        return v.date()\n    return v\n\n\nclass ChangeDateOfBirthToDateInUserInLatest(VersionChange):\n    description = (\n        \"Change 'BaseUser.date_of_birth' field type to datetime in HEAD \"\n        \"to support versions and data before 2001-01-01. \"\n    )\n    instructions_to_migrate_to_previous_version = (\n        schema(BaseUser).field(\"date_of_birth\").had(type=datetime.date),\n        # This step is only necessary in Pydantic 2 because datetime won't be converted\n        # to date automatically.\n        schema(BaseUser).validator(convert_date_of_birth_to_date).existed,\n    )\n</code></pre> </li> <li> <p>Add the following version change to <code>versions.v2001_01_01</code> (right under the version change above) which will make sure that <code>date_of_birth</code> is a datetime in 2000_01_01:</p> <pre><code>class ChangeDateOfBirthToDateInUser(VersionChange):\n    description = (\n        \"Change 'User.date_of_birth' field type to date instead of \"\n        \"a datetime because storing the exact time is unnecessary.\"\n    )\n    instructions_to_migrate_to_previous_version = (\n        schema(BaseUser).field(\"date_of_birth\").had(type=datetime.datetime),\n        schema(BaseUser).validator(convert_date_of_birth_to_date).didnt_exist,\n    )\n</code></pre> </li> <li> <p>Add both migrations into our VersionBundle:</p> <pre><code>from cadwyn import Version, VersionBundle, HeadVersion\nfrom datetime import date\nfrom .v2001_01_01 import MakePhoneNonNullableInLatest, AddPhoneToUser\n\n\nversion_bundle = VersionBundle(\n    HeadVersion(ChangeDateOfBirthToDateInUserInLatest),\n    Version(\"2001-01-01\", ChangeDateOfBirthToDateInUser),\n    Version(\"2000-01-01\"),\n)\n</code></pre> </li> </ol> <p>This whole process was a bit complex so let us break it down a little:</p> <ol> <li><code>date_of_birth</code> field is a datetime in HEAD, a date in 2001, and a datetime again in 2000.</li> <li>We needed some way to keep the 2000 behavior without allowing users in 2001 to use it. Cadwyn always converts all requests to the HEAD version so:<ul> <li>When we receive user creation requests from 2001, we convert them directly to HEAD, and pydantic casts date to datetime without any issue</li> <li>When we receive user get requests from 2001, we convert them directly from HEAD to latest, and our validator casts datetime to date (note that pydantic 1 would be able to do it even without a validator)</li> <li>When we receive user creation requests from 2000, we convert them directly to HEAD -- they have the same type for <code>date_of_birth</code> so it is easy to Cadwyn</li> <li>When we receive user get requests from 2000, we convert them directly from HEAD to 2000 -- they have the same type for <code>date_of_birth</code> so it is easy to Cadwyn</li> </ul> </li> </ol> <p>All of these interactions are done internally by Cadwyn. As you see, the process is more than straightforward: requests are converted to HEAD, and responses are converted from HEAD.</p> <p>Thus, we have kept old behavior, added new constrained behavior, and minimized the impact on our business logic as business logic simply doesn't know that <code>date_of_birth</code> in requests is ever a date and that <code>date_of_birth</code> in responses is ever a date. All of this information is hidden in our migration.</p> <p>A very important point here is that unlike schemas, routes, and business logic -- the migrations we wrote will likely never need to change because they describe the fundamental differences between the API versions, and these differences cannot be changed in the future because that would defeat the purpose of API versioning. This makes migrations effectively immutable and consequently very cheap to support.</p>"},{"location":"how_to/change_openapi_schemas/change_schema_without_endpoint/","title":"Change a schema that is not used in any endpoint","text":"<p>In some situations, we may want to use versioning not just for our OpenAPI schemas and endpoints but also within our code such as when we want to send versioned webhooks to our clients.</p> <p>For example, let's say we want to change the type of an \"id\" field from integer to string:</p> <pre><code>from pydantic import BaseModel\n\nfrom cadwyn import (\n    ResponseInfo,\n    VersionChange,\n    convert_response_to_previous_version_for,\n    schema,\n)\n\n\n# User from latest version\nclass User(BaseModel):\n    id: str\n\n\nclass ChangeUserIDToString(VersionChange):\n    description = (\n        \"Change users' ID field to a string to support any kind of ID. \"\n        \"Be careful: if you use a non-integer ID in a new version and \"\n        \"try to get it from the old version, the ID will be zero in response\"\n    )\n    instructions_to_migrate_to_previous_version = [\n        schema(User).field(\"id\").had(type=int),\n    ]\n\n    @convert_response_to_previous_version_for(User)\n    def change_id_to_int(response: ResponseInfo): ...\n</code></pre> <p>Unless there is an endpoint that has <code>User</code> as its response_model, this code will end up causing an error when we run our Cadwyn app. This is because Cadwyn tries to make sure that all of your converters apply to at least one endpoint. Otherwise, it would be too easy for you to make a mistake when writing converters for the wrong schemas.</p> <p>To avoid it, set <code>check_usage=False</code>:</p> <pre><code>from pydantic import BaseModel\n\nfrom cadwyn import (\n    ResponseInfo,\n    VersionChange,\n    convert_response_to_previous_version_for,\n    schema,\n)\n\n\n# User from latest version\nclass User(BaseModel):\n    id: str\n\n\nclass ChangeUserIDToString(VersionChange):\n    description = (\n        \"Change users' ID field to a string to support any kind of ID. \"\n        \"Be careful: if you use a non-integer ID in a new version and \"\n        \"try to get it from the old version, the ID will be zero in response\"\n    )\n    instructions_to_migrate_to_previous_version = [\n        schema(User).field(\"id\").had(type=int),\n    ]\n\n    @convert_response_to_previous_version_for(User, check_usage=False)\n    def change_id_to_int(response: ResponseInfo): ...\n</code></pre>"},{"location":"how_to/change_openapi_schemas/changing_constraints/","title":"Change field constraints or validators in OpenAPI schemas","text":""},{"location":"how_to/change_openapi_schemas/changing_constraints/#add-or-narrow-constraints","title":"Add or narrow constraints","text":"<p>Let's say that we previously allowed users to have a name of arbitrary length but now we want to limit it to 250 characters because we are worried that some users will be using inadequate lengths. You can't do this easily: if you simply add a <code>max_length</code> constraint to <code>User.name</code> -- the existing data in your database might become incompatible with this field in <code>UserResource</code>. So as long as incompatible data is there or can get there from some version -- you cannot add such a constraint to your responses. However, you can add it to your requests to prevent the creation of new user accounts with long names.</p> <ol> <li> <p>Change <code>max_length</code> of <code>data.v2001_01_01.users.UserCreateRequest.name</code> to 250 by adding the following migration to <code>versions.v2001_01_01</code>. We do this instead of just adding the constraint to HEAD to make sure that old requests will get converted to HEAD successfully -- without facing the constraint:</p> <pre><code>from cadwyn import VersionChange, schema\nfrom users import UserCreateRequest\n\n\nclass AddLengthConstraintToNameInLatest(VersionChange):\n    description = (\n        \"Remove the max_length constraint from the HEAD version to support \"\n        \"versions older than 2001_01_01 where it did not have the constraint.\"\n    )\n    instructions_to_migrate_to_previous_version = (\n        schema(UserCreateRequest).field(\"name\").had(max_length=250),\n    )\n</code></pre> </li> <li> <p>Then add this migration right under it into the same file:</p> <pre><code>class AddMaxLengthConstraintToUserNames(VersionChange):\n    description = (\n        \"Add a max length of 250 to user names when creating new users \"\n        \"to prevent overly large names from being used.\"\n    )\n    instructions_to_migrate_to_previous_version = (\n        schema(UserCreateRequest).field(\"name\").didnt_have(\"max_length\"),\n    )\n</code></pre> </li> <li> <p>Add both of these migrations into the version bundle:</p> <pre><code>from cadwyn import Version, VersionBundle, HeadVersion\nfrom datetime import date\nfrom .v2001_01_01 import (\n    AddLengthConstraintToNameInLatest,\n    AddMaxLengthConstraintToUserNames,\n)\n\nversion_bundle = VersionBundle(\n    HeadVersion(AddLengthConstraintToNameInLatest),\n    Version(\"2001-01-01\", AddMaxLengthConstraintToUserNames),\n    Version(\"2000-01-01\"),\n)\n</code></pre> </li> </ol> <p>So our HEAD version does not have this constraint, our latest does, and earlier versions do not.</p> <ul> <li>Requests from 2000 will be converted directly to HEAD and will not face this constraint because HEAD does not have it</li> <li>Requests from 2001 will first be validated by 2001 schemas with this constraint, and then will be converted to HEAD too</li> </ul> <p>Note, however, that anyone using the old API versions will will still be able to use arbitrary length names in older API versions. If you want to prevent that, then the correct approach would instead be the following:</p> <ol> <li>Check whether any users have names longer than 250 characters. If there are few or no users that have such long names, then it may make sense to skip step 1. The other steps, however, cannot be skipped if you want to guarantee that your API gives no 500s at any point in the process.</li> <li>Issue a 3-6 month warning to all users stating that you will make a breaking change affecting older versions. Mention that you will truncate old names that are longer than 250 characters and that users will no longer be able to create such long names even in old API versions.</li> <li>After the deadline, add a <code>max_length</code> constraint to <code>users.UserCreateRequest.name</code></li> <li>Release it to production</li> <li>Truncate all names that are too long in the database (preferably using a migration and a separate release)</li> <li>Remove the <code>max_length</code> constraint from <code>users.UserCreateRequest.name</code></li> <li>Add the <code>max_length</code> constraint to <code>users.BaseUser.name</code></li> </ol> <p>This process seems quite complex but it's not Cadwyn-specific: if you want to safely and nicely version for your users, you will have to follow such a process even if you don't use any versioning framework at all.</p>"},{"location":"how_to/change_openapi_schemas/changing_constraints/#remove-or-expand-constraints","title":"Remove or expand constraints","text":"<p>Let's say that we previously only allowed users to have a name of length 50 but now we want to allow names of length 250 too. It does not make sense to add this to a new API version. Just add it into all API versions because it is not a breaking change.</p> <p>You just need to change <code>max_length</code> of <code>users.BaseUser.name</code> to 250</p> <p>However, sometimes it can be considered a breaking change if a large portion of your users use your system to verify their data and rely on your system to return status code <code>422</code> if this field is invalid. If that's the case, use the same approach as in constraint addition but use <code>schema(UserCreateRequest).field(\"name\").had(max_length=50)</code> instead.</p>"},{"location":"how_to/change_openapi_schemas/changing_constraints/#add-or-remove-validators","title":"Add or remove validators","text":"<p>The same approach as above could be used to add or remove pydantic validator functions using validator generation. Note that adding validators is the same as narrowing or adding constraints, which means that the same trick as above should be used.</p>"},{"location":"how_to/change_openapi_schemas/remove_field/","title":"Remove a field from OpenAPI schemas","text":""},{"location":"how_to/change_openapi_schemas/remove_field/#from-response","title":"From response","text":"<p>Let's say that our API has a mandatory <code>UserResource.date_of_birth</code> field. Let's also say that our API has previously exposed user's zodiac sign. Our analysts have decided that it does not make sense to store or send this information as it does not affect the functionality and can be inferred from date of birth.</p> <ol> <li>Remove <code>zodiac_sign</code> field from <code>users.UserResource</code></li> <li> <p>Add the following migration to <code>versions.v2001_01_01</code>:</p> <pre><code>from cadwyn import VersionChange, schema\nfrom users import UserResource\nfrom pydantic import Field\n\n\nclass RemoveZodiacSignFromUser(VersionChange):\n    description = (\n        \"Remove 'zodiac_sign' field from UserResource because \"\n        \"it can be inferred from user's date of birth and because \"\n        \"only a small number of users has utilized it.\"\n    )\n    instructions_to_migrate_to_previous_version = (\n        schema(UserResource)\n        .field(\"zodiac_sign\")\n        .existed_as(type=str, info=Field(description=\"User's magical sign\")),\n    )\n</code></pre> </li> <li> <p>Add this migration into the version bundle:</p> <pre><code># versions/__init__.py\n\nfrom cadwyn import Version, VersionBundle, HeadVersion\nfrom datetime import date\nfrom .v2001_01_01 import RemoveZodiacSignFromUser\n\nversion_bundle = VersionBundle(\n    HeadVersion(),\n    Version(\"2001-01-01\", RemoveZodiacSignFromUser),\n    Version(\"2000-01-01\"),\n)\n</code></pre> </li> </ol> <p>Thanks to the version change above, your old schemas will now include <code>zodiac_sign</code> field but your new schemas will stay the same. Don't remove the zodiac business logic from your router because the old version will still need it. So you always return the zodiac sign but the schemas of the latest version will ignore it.</p> <p>You can remove the logic for calculating and returning the zodiac sign after version <code>2000-01-01</code> gets deleted.</p>"},{"location":"how_to/change_openapi_schemas/remove_field/#from-both-request-and-response","title":"From both request and response","text":""},{"location":"how_to/change_openapi_schemas/remove_field/#optional-field","title":"Optional field","text":"<p>Let's say that we had a nullable <code>middle_name</code> field but we decided that it does not make sense anymore and want to remove it now from both requests and responses. This means that a user from an old version will still be able to pass it while the user from a new version will not. We can solve this by having this field in our HEAD, removing it from our latest version but keeping it in all older versions:</p> <ol> <li>Keep storing <code>middle_name</code> in your database in order to support old versions</li> <li> <p>Add the following migration to <code>versions.v2001_01_01</code> to remove <code>middle_name</code> from the latest version:</p> <pre><code>from cadwyn import VersionChange, schema\nfrom users import BaseUser\n\n\nclass RemoveMiddleNameFromLatestVersion(VersionChange):\n    description = (\n        \"Remove 'User.middle_name' from latest but keep it in HEAD \"\n        \"to support versions before 2001-01-01.\"\n    )\n    instructions_to_migrate_to_previous_version = (\n        schema(BaseUser).field(\"middle_name\").didnt_exist,\n    )\n</code></pre> </li> <li> <p>Add the following migration to <code>versions.v2001_01_01</code> to leave support for <code>middle_name</code> in the older versions:</p> <pre><code>from cadwyn import VersionChange, schema\nfrom users import BaseUser\n\n\nclass RemoveMiddleNameFromUser(VersionChange):\n    description = \"Remove 'User.middle_name' field\"\n    instructions_to_migrate_to_previous_version = (\n        schema(BaseUser)\n        .field(\"middle_name\")\n        .existed_as(\n            type=str | None,\n            info=Field(description=\"User's Middle Name\", default=None),\n        ),\n    )\n</code></pre> </li> <li> <p>Add these migrations into the version bundle:</p> <pre><code># versions/__init__.py\n\nfrom cadwyn import Version, VersionBundle, HeadVersion\nfrom datetime import date\nfrom .v2001_01_01 import RemoveZodiacSignFromUser\n\nversion_bundle = VersionBundle(\n    HeadVersion(RemoveMiddleNameFromLatestVersion),\n    Version(\"2001-01-01\", RemoveMiddleNameFromUser),\n    Version(\"2000-01-01\"),\n)\n</code></pre> </li> </ol> <p>We added a new version with a breaking change but neither the HEAD schema that we use in business logic, neither has the business logic itself have changed one bit.</p>"},{"location":"how_to/change_openapi_schemas/remove_field/#required-field","title":"Required field","text":"<p>There are two main cases with required fields:</p> <ol> <li>Remove a required field with a simple fake default (created_at)</li> <li>Remove a required field with an impossible default (tax id)</li> </ol> <p>The first one is simple to solve: just use the approach above but use a <code>default_factory=datetime.datetime.now</code> instead of <code>default=None</code>.</p> <p>Now what about case 2?</p> <p>Let's say that you have company resources in your system. Let's also say that each company has a <code>tax_id</code> and now you would like to remove the <code>tax_id</code> field or make it optional. If <code>tax_id</code> was required in your responses, you can't really do this with traditional API versioning because you cannot come up with a sane non-null default for <code>tax_id</code>. It is a case of data versioning where you try to make an API version that is inconsistent with other API versions in terms of its data. You deal with this using one of the following approaches:</p> <ol> <li>Talk to your users. In any API versioning problem, talking to your users is the best first step. See whether this is actually a breaking change for them. Maybe only a small subset of your users is using this field and you can migrate this subset manually without much investment, which will allow you to make the breaking changes without breaking anyone's API. Though this approach becomes impossible to use once you get a lot of clients.</li> <li>Issue a warning to your users that <code>tax_id</code> is going to become optional in all API versions in <code>N</code> months and then make it so. This will allow you to avoid data versioning and your users will have a grace period to fix their issues. Then you can simply follow the approach above.</li> <li>Release a <code>V2</code> version of your API which users will have to migrate their data to. This is a drastic approach and you should only reserve it for extreme cases but it is a correct way to represent data versioning.</li> <li>Disallow the new version (2001-01-01) to be used alongside older versions and disallow users to migrate to older versions after they have migrated to 2001-01-01. Then you can simply follow the approach above. This is a dirty hack and an inconvenience to your users but it solves the problem too, albeit I would never recommend to use this solition.</li> </ol>"},{"location":"how_to/change_openapi_schemas/rename_a_field_in_schema/","title":"Rename a field in schema","text":"<p>Let's say that we had a \"summary\" field before but now we want to rename it to \"bio\".</p> <ol> <li>Rename <code>summary</code> field to <code>bio</code> in <code>users.BaseUser</code></li> <li> <p>Add the following migration to <code>versions.v2001_01_01</code>:</p> <pre><code>from cadwyn import (\n    VersionChange,\n    schema,\n    convert_response_to_previous_version_for,\n    convert_request_to_next_version_for,\n    ResponseInfo,\n    RequestInfo,\n)\nfrom users import BaseUser, UserCreateRequest, UserResource\n\n\nclass RenameSummaryIntoBioInUser(VersionChange):\n    description = (\n        \"Rename 'summary' field into 'bio' to keep up with industry standards\"\n    )\n    instructions_to_migrate_to_previous_version = (\n        schema(BaseUser).field(\"bio\").had(name=\"summary\"),\n    )\n\n    @convert_request_to_next_version_for(UserCreateRequest)\n    def rename_bio_to_summary(request: RequestInfo):\n        request.body[\"summary\"] = request.body.pop(\"bio\")\n\n    @convert_response_to_previous_version_for(UserResource)\n    def rename_bio_to_summary(response: ResponseInfo):\n        response.body[\"bio\"] = response.body.pop(\"summary\")\n</code></pre> </li> </ol>"},{"location":"quickstart/setup/","title":"Setup","text":"<p>Cadwyn is built around FastAPI and supports all of its functionality out of the box. One difference is that Cadwyn requires you to define API versions and extends your routing and swagger to support API versioning.</p>"},{"location":"quickstart/setup/#installation","title":"Installation","text":"<pre><code>pip install 'cadwyn[standard]'\n</code></pre>"},{"location":"quickstart/setup/#the-basics","title":"The basics","text":"<p>First, let's set up the most basic versioned app possible:</p> <pre><code>from cadwyn import Cadwyn, HeadVersion, Version, VersionBundle\n\napp = Cadwyn(versions=VersionBundle(HeadVersion(), Version(\"2000-01-01\")))\n\n\n@app.get(\"/\")\nasync def root():\n    return {\"message\": \"Hello World\"}\n</code></pre> <p>and run it using:</p> <pre><code>fastapi dev main.py\n</code></pre> <p>That's it. That's the main difference between setting up FastAPI and Cadwyn: you have to specify your versions. Everything you specify at app level (such as using <code>include_router</code> or <code>app.get(...)</code>) will end up unversioned and essentially function like a regular FastAPI route.</p>"},{"location":"quickstart/setup/#docs","title":"Docs","text":"<p>If you visit <code>/docs</code>, instead of the regular swagger, you will see a version dashboard:</p> <p></p> <p>Clicking a card will take you to the card's regular swagger page. If you wish to see the <code>openapi.json</code> for a specific version, just use <code>/openapi.json?version=2000-01-01</code> (or whatever version you want to get).</p>"},{"location":"quickstart/tutorial/","title":"Tutorial","text":"<p>This guide provides steps for setting up automatic API versioning using Cadwyn. I will illustrate this with an example of a User API, where we will be implementing changes to a User's address. You can also see the advanced version of the service from this tutorial here.</p> <p>Adding a new API version in Cadwyn consists of two main steps:</p> <ol> <li>Make the breaking change</li> <li>Use Cadwyn to describe how to revert the breaking change</li> </ol> <p>In this guide, we'll prepare an environment for working with Cadwyn effectively with a basic usage example, make a breaking change, and then show how Cadwyn can help us keep the old API versions untouched.</p>"},{"location":"quickstart/tutorial/#step-0-setting-up","title":"Step 0: Setting up","text":"<p>Let's follow the steps we discussed before for versioning using Cadwyn.</p> <p>Here is an initial API setup where the User has a single address. We will be implementing two routes - one for creating a user and another for retrieving user details. We'll be using \"int\" for ID for simplicity. Please note that we will use a dict in place of a database for simplicity of our examples but do not ever do it in real life.</p> <p>The first API you come up with usually doesn't require more than one address -- why bother?</p> <pre><code>import uuid\n\nfrom pydantic import BaseModel\n\nfrom cadwyn import (\n    Cadwyn,\n    Version,\n    VersionBundle,\n    VersionedAPIRouter,\n)\n\n\nclass UserCreateRequest(BaseModel):\n    address: str\n\n\nclass UserResource(BaseModel):\n    id: uuid.UUID\n    address: str\n\n\ndatabase_parody = {}\nrouter = VersionedAPIRouter()\n\n\n@router.post(\"/users\")\nasync def create_user(payload: UserCreateRequest) -&gt; UserResource:\n    id_ = uuid.uuid4()\n    database_parody[id_] = UserResource(id=id_, address=payload.address)\n    return database_parody[id_]\n\n\n@router.get(\"/users/{user_id}\")\nasync def get_user(user_id: uuid.UUID) -&gt; UserResource:\n    return database_parody[user_id]\n\n\napp = Cadwyn(versions=VersionBundle(Version(\"2000-01-01\")))\napp.generate_and_include_versioned_routers(router)\n</code></pre> <p>If we visit <code>/docs</code>, we will see the following dashboard:</p> <p></p> <p>The app is ready to be used. Every time you would like to call its endpoints, you just need to pass <code>X-API-VERSION</code> header with value equal to <code>2000-01-01</code>. But this is just one version. Let us see what happens when we need to make a breaking change. Cadwyn supports multiple versioning styles, including header-based, path-based, and number-based.</p>"},{"location":"quickstart/tutorial/#step-1-making-the-breaking-change","title":"Step 1: Making the breaking change","text":"<p>During our development, we have realized that the initial API design was wrong and that addresses should have always been a list because the user wants to have multiple addresses to choose from so now we have to change the type of the \"address\" field to the list of strings.</p> <pre><code>import uuid\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field\n\nfrom cadwyn import (\n    Cadwyn,\n    Version,\n    VersionBundle,\n    VersionedAPIRouter,\n)\n\n\nclass UserCreateRequest(BaseModel):\n    addresses: list[str]\n\n\nclass UserResource(BaseModel):\n    id: uuid.UUID\n    addresses: Annotated[list[str], Field(min_length=1)]\n\n\ndatabase_parody = {}\nrouter = VersionedAPIRouter()\n\n\n@router.post(\"/users\")\nasync def create_user(payload: UserCreateRequest) -&gt; UserResource:\n    id_ = uuid.uuid4()\n    database_parody[id_] = UserResource(id=id_, addresses=payload.addresses)\n    return database_parody[id_]\n\n\n@router.get(\"/users/{user_id}\")\nasync def get_user(user_id: uuid.UUID) -&gt; UserResource:\n    return database_parody[user_id]\n\n\napp = Cadwyn(versions=VersionBundle(Version(\"2001-01-01\")))\napp.generate_and_include_versioned_routers(router)\n</code></pre> <p>Now, every user of ours will have their API integration broken. To prevent that, we have to introduce API versioning. There aren't many methods of doing that. Most of them force you to either duplicate your schemas, your endpoints, or your entire app instance. And it makes sense, really: duplication is the only way to make sure that you will not break old versions with your new versions; the bigger the piece you duplicating -- the safer. Of course, the safest being duplicating the entire app instance and even having a separate database. But that is expensive and makes it either impossible to make breaking changes often or to support many versions. As a result, either you need infinite resources, very long development cycles, or your users will need to often migrate from version to version.</p> <p>Stripe has come up with a solution: let's have one HEAD app version whose responses get migrated to older versions and let's describe changes between these versions using migrations. This approach allows them to keep versions for years without dropping them. Obviously, each breaking change is still bad and each version still makes our system more complex and expensive, but their approach gives us a chance to minimize this complexity. Additionally, it allows us backport features and bugfixes to older versions. However, you will also be backporting bugs, which is a sad consequence of eliminating duplication.</p> <p>Imagine you needed to know what your code looked like two weeks ago. You would use <code>git checkout</code> or <code>git reset</code> with an older commit because <code>git</code> stores the latest version of your code (which is also called HEAD) and the differences between it and each previous version as a chain of changes. This is exactly how Stripe's approach works! They store the latest version and use the diffs to regenerate the older versions.</p> <p>Cadwyn builds upon approach so let's continue our tutorial and try to combine the two versions we created using versioning.</p> Note to curious readers    Git doesn't actually work this way internally. My description is closer to how SVN works. It's just a really simplistic metaphor to explain a concept."},{"location":"quickstart/tutorial/#step-2-describing-how-to-revert-the-breaking-change","title":"Step 2: Describing how to revert the breaking change","text":"<p>To fix the old integrations of our clients, we need to add back the <code>2000-01-01</code> version and its state. In Cadwyn, it is done using version changes (or, as Stripe calls them, version gates). You could also think of them as reverse database migrations (database migrations to downgrade to the previous state of the database). Essentially version changes describe the difference between the latest version and the previous version. They are a way to say \"Okay, we have applied the breaking changes but here is how we would revert these changes for our old clients\".</p> <p>For every endpoint whose <code>response_model</code> is <code>UserResource</code>, this migration will convert the list of addresses back to a single address when migrating to the previous version. Our goal is to have an app of HEAD version and to describe what older versions looked like in comparison to it. That way the old versions are frozen in migrations and you can almost safely forget about them.</p> <pre><code>import uuid\nfrom typing import Annotated\n\nfrom cadwyn import (\n    Cadwyn,\n    RequestInfo,\n    ResponseInfo,\n    Version,\n    VersionBundle,\n    VersionChange,\n    VersionedAPIRouter,\n    convert_request_to_next_version_for,\n    convert_response_to_previous_version_for,\n    schema,\n)\nfrom pydantic import BaseModel, Field\n\n\nclass UserCreateRequest(BaseModel):\n    addresses: list[str]\n\n\nclass UserResource(BaseModel):\n    id: uuid.UUID\n    addresses: Annotated[list[str], Field(min_length=1)]\n\n\ndatabase_parody = {}\nrouter = VersionedAPIRouter()\n\n\n@router.post(\"/users\")\nasync def create_user(payload: UserCreateRequest) -&gt; UserResource:\n    id_ = uuid.uuid4()\n    database_parody[id_] = UserResource(id=id_, addresses=payload.addresses)\n    return database_parody[id_]\n\n\n@router.get(\"/users/{user_id}\")\nasync def get_user(user_id: uuid.UUID) -&gt; UserResource:\n    return database_parody[user_id]\n\n\nclass ChangeAddressToList(VersionChange):\n    description = (\n        \"Give user the ability to have multiple addresses at the same time\"\n    )\n    instructions_to_migrate_to_previous_version = (\n        schema(UserCreateRequest)\n        .field(\"addresses\")\n        .had(name=\"address\", type=str),\n        schema(UserResource).field(\"addresses\").had(name=\"address\", type=str),\n    )\n\n    @convert_request_to_next_version_for(UserCreateRequest)\n    def change_address_to_multiple_items(request: RequestInfo):\n        request.body[\"addresses\"] = [request.body.pop(\"address\")]\n\n    @convert_response_to_previous_version_for(UserResource)\n    def change_addresses_to_single_item(response: ResponseInfo) -&gt; None:\n        response.body[\"address\"] = response.body.pop(\"addresses\")[0]\n\n\napp = Cadwyn(\n    versions=VersionBundle(\n        Version(\"2001-01-01\", ChangeAddressToList),\n        Version(\"2000-01-01\"),\n    )\n)\napp.generate_and_include_versioned_routers(router)\n</code></pre> <p>See how we are popping the first address from the list? This is only guaranteed to be possible because we specified earlier that <code>min_length</code> for <code>addresses</code> must be <code>1</code>. If we didn't, then the user would be able to create a user in a newer version that would be impossible to represent in the older version. I.e. If anyone tried to get that user from the older version, they would get a <code>ResponseValidationError</code> because the user wouldn't have data for a mandatory <code>address</code> field. You need to always keep in mind that API versioning is only for versioning your API, your interface. Your versions must still be completely compatible in terms of data. If they are not, then you are versioning your data and you should really go with a separate app instance. Otherwise, your users will have a hard time migrating back and forth between API versions and so many unexpected errors.</p> <p>See how we added a migration not only for response but also for request? This will allow our business logic to stay completely the same, no matter which version it was called from. Cadwyn will always give your business logic the request model from the HEAD version by wrapping each request in it.</p> <p>Let's run our app and take a look at the generated dashboard and OpenAPI schemas:</p> <p> </p> <p>The endpoint above is from the <code>2000-01-01</code> version. As you see, our routes and business logic are for the HEAD version but our OpenAPI has all information about all API versions which is the main goal of Cadwyn: a large number of long-living API versions without placing any burden on your business logic.</p> <p>Obviously, this was just a simple example and cadwyn has a lot more features so if you're interested -- take a look at the how-to and concepts sections.</p>"},{"location":"theory/how_to_build_versioning_framework/","title":"How to build a versioning framework","text":""},{"location":"theory/how_to_build_versioning_framework/#questions-to-ask-yourself-when-rating-your-framework","title":"Questions to ask yourself when rating your framework","text":""},{"location":"theory/how_to_build_versioning_framework/#how-easy-is-it-to-create-a-version","title":"How easy is it to create a version?","text":"<p>If it is too easy, it is probably a trap. The framework is probably hiding too much complexity from you and will shoot you in the back later. For example, early on we tried a simple \"copy the entire business logic into a separate directory\" approach which made it so simple to add new versions. We added too many of them in the end, thus it got hellishly hard to maintain or get rid of these versions.</p>"},{"location":"theory/how_to_build_versioning_framework/#how-easy-is-it-to-delete-an-old-version","title":"How easy is it to delete an old version?","text":"<p>Your framework must be able to let you clean up versions as simply as possible and cheaply whenever you need to. For example, if your framework tries to minimize the amount of code duplication in your repository by having new routes include old routes within them and new business logic inherit from classes from old business logic, then deleting an old version is going to be painful; oftentimes even dangerous as versions can quickly start interacting with each other in all sorts of ways, turning a single small application into a set of interconnected applications.</p>"},{"location":"theory/how_to_build_versioning_framework/#how-easy-is-it-to-see-the-differences-between-versions","title":"How easy is it to see the differences between versions?","text":"<p>The easier it is, the better off our users are.</p>"},{"location":"theory/how_to_build_versioning_framework/#what-exactly-do-you-need-to-duplicate-to-create-a-new-version","title":"What exactly do you need to duplicate to create a new version?","text":"<p>The less we duplicate and maintain manually, the easier it is to support. However, the less we duplicate, the higher the risk of breaking old versions with new releases.</p>"},{"location":"theory/how_to_build_versioning_framework/#how-easy-is-it-to-notice-accidental-data-versioning","title":"How easy is it to notice accidental data versioning?","text":"<p>Data versioning is an incredibly big issue when versioning your API. So if your framework makes it hard to version data -- it's really good!</p>"},{"location":"theory/how_we_got_here/","title":"How we got here","text":"<p>Over the years we have seen so many ways to do API Versioning. In fact, the majority of these ways can be put into an elegant evolution. Let's go through it from the largest level of duplication to the smallest.</p>"},{"location":"theory/how_we_got_here/#types-of-api-versioning","title":"Types of API versioning","text":"<p>There are three ([1], [2]) main ways to version an API, each consequent being less safe but more convenient to both the API clients and maintainers. Essentially they can be classified by which layers of MVC they version.</p>"},{"location":"theory/how_we_got_here/#1-versioning-proxy-which-points-requests-to-versioned-apps","title":"1. Versioning proxy, which points requests to versioned apps","text":"<p>This approach versions all three layers: separate data, separate business logic, separate representation. Essentially you create a completely different app for each version. Your versions are independent and cannot in any way affect each other. You can make any sorts of changes in future versions without worrying about breaking the old ones.</p> <p>This approach is the most expensive to support but if breaking old functionality is unacceptable and if you need to support a small number of versions (1-3), then this option is viable.</p> <p>Note that this is essentially data or application versioning, not API versioning anymore. If it is impossible for your user to freely move between API versions (back and forth), then you are probably doing a bit of data versioning yourself. It can simplify your app's logic but will significantly inconvenience your users because they will not be able to easily switch API versions without waiting for your team to help. Additionally, a single client will never be able to use two versions at the same time. At least not easily.</p> <p>Mostly used in older-style apps or in critical infrastructure where no mistakes are permitted</p>"},{"location":"theory/how_we_got_here/#2-one-router-which-points-requests-to-versioned-controllers","title":"2. One router, which points requests to versioned controllers","text":"<p>This approach versions business logic and representation layers while leaving data layer the same. You still have to duplicate all of your business logic but now your clients will be able to migrate between versions easily and you will be able to share some of the code between versions, thus lowering the amount of things you would need to duplicate.</p> <p>The problem with this method is that any refactoring will most likely have to happen in all versions at once. Any changes in the libraries they depend on will also require a change in all versions. When the number of versions starts to rise (&gt;2), this becomes a significant problem for the performance and morale of API maintainers.</p> <p>This is also the approach we have originally started with. It is likely the worst one out there due to its fake simplicity and actual complexity. In the long run, this approach is one of the hardest to support but most importantly: it's probably the hardest to migrate from.</p> <p>Popular in .NET environment and is likely the first choice of any API due to the simplicity of its implementation</p>"},{"location":"theory/how_we_got_here/#3-one-router-shared-controllers-which-respond-with-versioned-representations","title":"3. One router, shared controllers, which respond with versioned representations","text":"<p>This approach versions only the API itself. The business logic and data below the API is the same for all versions (with rare exceptions) so API maintainers have the pleasure of maintaining only one API version while users have the added benefit that non-breaking featurees and bugfixes will automatically be ported to their version. This is the only method that allows you to support a large number of versions because it has the least amount of duplication of all methods. This is usually accomplished by adding a separate layer that builds responses out of the data that your service returns. It can be a separate service, a framework, or just a set of functions.</p> <p>Note that in this method, the usage of data versioning now becomes an inconvenience to both API users and maintainers. See, when you have a single business logic for all versions, you might need additional conditionals and checks for versions where data structure or data itself has changed. That is in addition to pre-existing inconveniences for the users. However, sometimes it might still happen so our goal is to minimize the frequency and impact of data versioning.</p> <p>Popular in API-First tech giants that have to support backwards compatibility for a long time for a large number of clients</p> <p>Note that this approach actually has two important subtypes:</p>"},{"location":"theory/how_we_got_here/#i-duplication-based-response-building","title":"i. Duplication-based response building","text":"<p>The simplest possible builder: for each API version, we define a new request/response builder that builds the full response for the altered API routes or migrates the user request to the latest version. It is incredibly simple to implement but is not scalable at all. Adding values to all builders will require going through all of them with the hope of not making mistakes or typos. Trying to support more than 8-12 versions with this approach will still be challenging.</p> <p>We might think of smart ways of automating this approach to support a larger number of versions. For example, to avoid duplicating the entire builder logic every time, we can pick a template builder and only define differences in child builders. Let's pick the latest-version builder as template because it will never be deprecated deleted and our developers will have the most familiarity with it. Then we need to figure out a format to define changes between builders. We can remove a field from response, add a field, change the value of a field somehow, and/or change the type of a field. We'll need some DSL to describe all possible changes.</p> <p>Then we start thinking about API route differences. How do we describe them? Or do we just duplicate all routes? Do we maybe use inheritance? No matter what we do, we'll eventually also come to a DSL, which is why some tech giants have chosen approach ii.</p> <p>A code generation yaml-based version of this approach was used at SuperJob.</p>"},{"location":"theory/how_we_got_here/#ii-migration-based-response-building","title":"ii. Migration-based response building","text":"<p>This is effectively an automated version of approach i. It has the minimal possible amount of duplication compared to all other approaches. Using a specialized DSL, we define schema migrations for changes in our request and response schemas, we define compatibility gates to migrate our data in accordance with schema changes, and we define route migrations to change/delete/add any routes.</p> <p>This is the method that Stripe, Linkedin, and Intercom have picked and this is the method that Cadwyn implements for you.</p>"},{"location":"theory/literature/","title":"Literature","text":"<p>During Cadwyn's development, I went through countless resources on API Versioning. The following are the most unique and effective ones I managed to find.</p>"},{"location":"theory/literature/#cadwyn-like-api-versioning","title":"Cadwyn-like API Versioning","text":""},{"location":"theory/literature/#articles","title":"Articles","text":"<ul> <li>API Versioning at Stripe</li> <li>API Versioning at Intercom</li> <li>Rolling Versions at Convoy</li> <li>Breaking Things Without Breaking Things at Keygen</li> <li>API Versioning at LinkedIn Marketing</li> </ul>"},{"location":"theory/literature/#projects","title":"Projects","text":""},{"location":"theory/literature/#python","title":"Python","text":"<ul> <li>Django REST Framework Versioning</li> </ul>"},{"location":"theory/literature/#golang","title":"Golang","text":"<ul> <li>Pinned</li> <li>Request Migrations for Go (by the author of Convoy)</li> </ul>"},{"location":"theory/literature/#ruby","title":"Ruby","text":"<ul> <li>Gates</li> <li>Request Migrations for Ruby</li> </ul>"},{"location":"theory/literature/#php","title":"PHP","text":"<ul> <li>Laravel API Migrations</li> <li>Request Migrations for PHP</li> </ul>"},{"location":"theory/literature/#overview-articles-on-api-versioning","title":"Overview articles on API Versioning","text":"<ul> <li>Developing an API</li> <li>API versioning has no right way</li> <li>The tricks of API Versioning</li> <li>Versioning API in Django REST Framework</li> </ul>"},{"location":"theory/literature/#other-articles-on-api-versioning","title":"Other articles on API Versioning","text":"<ul> <li>Postman API Platform: API Versioning</li> <li>Four REST API Versioning Strategies</li> <li>The Ultimate Guide to Microservices Versioning Best Practices</li> <li>ASP.NET API Versioning on GitHub</li> <li>API Versioning at SuperJob</li> <li>Better API Versioning with Semantic Versioning in Django REST Framework</li> <li>How Badoo Versions its API for internal clients</li> </ul>"}]}